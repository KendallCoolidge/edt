package org.eclipse.edt.compiler.internal.pgm.dli;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.Symbol;

import org.eclipse.edt.compiler.internal.EGLBasePlugin;
import org.eclipse.edt.compiler.internal.EGLValidationMessages;
import org.eclipse.edt.compiler.internal.util.EGLMessage;

parser code {:
  	private String parseString;

  	List messages = new ArrayList();
  	DLIEGLParser eglParser = new DLIEGLParser();
  	
  
    /* (non-Javadoc)
     * @see java_cup.runtime.lr_parser#report_error(java.lang.String, java.lang.Object)
     */
    public void report_error(String message, Object info) {
        Symbol symbol = (Symbol) info;
        messages.add(EGLMessage.createEGLSytaxErrorMessage(
                EGLBasePlugin.EGL_VALIDATION_RESOURCE_BUNDLE,
                EGLValidationMessages.EGLMESSAGE_UNEXPECTED_TOKEN,
                new String[] { ((DLILexer) getScanner()).yytext() },
                symbol.left,
                symbol.right
        ));				
    }
    
    public int getHostVariableLength(int startPosition) {
    	return eglParser.getHostVariableLength(parseString.substring(startPosition));
   	}
    
    public DLIModel parse(String string) throws Exception {
        this.parseString = string;
        
        DLILexer lexer = new DLILexer(new StringReader(string));
        setScanner(lexer);
        lexer.setParser(this);

        this.parseString = null;
        
        return (DLIModel) parse().value;
    }
:};

// Special tokens
terminal String HOSTVAR;
terminal ERROR;

terminal String FUNCTIONNAME;

// Identifiers and Literals
terminal String ID;
terminal String INTEGERLIT;
terminal String DECIMALLIT;
terminal String FLOATLIT;
terminal String SINGLE_QUOTED_STRINGLIT;
terminal String STRINGLIT;

// Symbols and Operators
terminal String RELATIONOP;
terminal String BOOLEANOP;

terminal LPAREN;
terminal RPAREN;

terminal LBRACKET;
terminal RBRACKET;

terminal ASTERISK;

nonterminal IDLIModel dli;
nonterminal IStatement statement;
nonterminal String functionName;
nonterminal ISegmentSearchArgument ssa;
nonterminal ICommandCodes commandCodes_opt;
nonterminal ISSAConditions conditions_opt;
nonterminal IBooleanExpression conditions;
nonterminal ICondition condition;
nonterminal IName name;
nonterminal IValue value;

nonterminal List statement_star, statement_plus;
nonterminal List ssa_star, ssa_plus;

dli
	::=	statement_star:statements1
	{: RESULT = new DLIModel(statements1, parser.messages, statements1left, statements1right); :}
	;
	
statement
	::=	functionName:functionName1 ssa_star:ssas1
	{: RESULT = new Statement(functionName1, ssas1, functionName1left, ssas1right); :}
	|	error
	;
	
functionName
	::=	FUNCTIONNAME:functionName1
	{: RESULT = functionName1; :}
	;
	
ssa
	::=	name:name1 commandCodes_opt:commandCodes1 conditions_opt:conditions1
	{: RESULT = new SegmentSearchArgument(name1, commandCodes1, conditions1, name1left, conditions1right); :}
	;
	
commandCodes_opt
	::=	
	|	ASTERISK ID:id1
	{: RESULT = new CommandCodes(id1, id1left, id1right); :}
	;
	
conditions_opt
	::=	
	|	LPAREN conditions:conditions1 RPAREN
	{: RESULT = new BooleanExpressionSSAConditions(conditions1, conditions1left, conditions1right); :}
	|	LPAREN value:value1 RPAREN
	{: RESULT = new ValueExpressionSSAConditions(value1, value1left, value1right); :}
	;
	
conditions
	::=	condition:condition1
	{: RESULT = condition1; :}
	|	conditions:left1 BOOLEANOP:operator1 condition:right1
	{: RESULT = new BooleanOperatorExpression(left1, operator1, right1, left1left, right1right); :}
	;
	
condition
	::=	name:fieldName1 RELATIONOP:operator1 value:value1
	{: RESULT = new Condition(fieldName1, operator1, value1, fieldName1left, value1right); :}
	;
	
name
	::=	ID:id1
	{: RESULT = new SimpleName(id1, id1left, id1right); :}
	|	SINGLE_QUOTED_STRINGLIT:quotedName1
	{: RESULT = new QuotedName(quotedName1, quotedName1left, quotedName1right); :}
	;
	
value
	::=	INTEGERLIT:value1
	{: RESULT = new IntegerLiteralValue(value1, value1left, value1right); :}
	|	DECIMALLIT:value1
	{: RESULT = new DecimalLiteralValue(value1, value1left, value1right); :}
	|	FLOATLIT:value1
	{: RESULT = new FloatLiteralValue(value1, value1left, value1right); :}
	|	STRINGLIT:value1
	{: RESULT = new StringLiteralValue(value1, value1left, value1right); :}
	|	HOSTVAR:dataAccessString1
	{: RESULT = new HostVariableValue(dataAccessString1, dataAccessString1left, dataAccessString1right); :}
	;
	
statement_star
	::=
	{: RESULT = new ArrayList(); :}
	|	statement_plus:statements
	{: RESULT = statements; :}
	;
	
statement_plus
	::=	statement:statement
	{: RESULT = new ArrayList(); if(statement != null) RESULT.add(statement); :}
	|	statement_plus:statements statement:statement
	{: if(statement != null) statements.add(statement); RESULT = statements; :}
	;
	
ssa_star
	::=	
	{: RESULT = new ArrayList(); :}
	|	ssa_plus:ssas
	{: RESULT = ssas; :}
	;
	
ssa_plus
	::=	ssa:ssa
	{: RESULT = new ArrayList(); RESULT.add(ssa); :}
	|	ssa_plus:ssas ssa:ssa
	{: ssas.add(ssa); RESULT = ssas; :}
	;
	