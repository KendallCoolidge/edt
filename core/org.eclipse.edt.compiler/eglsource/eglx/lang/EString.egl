package eglx.lang;

import egl.lang.EglAny;
import egl.lang.EglNumber;
import egl.lang.EglString;
import egl.lang.reflect.ParameterizableType;
import egl.lang.reflect.mof.Operation;

import org.eclipse.edt.mof.egl.SequenceType;

externalType EString extends EglString type ParameterizableType {
	parameterizedType = SequenceType
}
	/**
	 * {@Operation +} Concatenates a string and an Any.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $Plus(lvalue EString in, rvalue EglAny in) returns(EString) {@Operation{"+"}};

	/**
	 * {@Operation +} Concatenates an Any and a string.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $Plus(lvalue EglAny in, rvalue EString in) returns(EString) {@Operation{"+"}};

	/**
	 * {@Operation ::} Concatenates a string and an Any.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $Concat(value EString in, rvalue EglAny in) returns (EString) {@Operation{"::"}};

	/**
	 * {@Operation ::} Concatenates an Any and a string.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $Concat(value EglAny in, rvalue EString in) returns (EString) {@Operation{"::"}};

	/**
	 * {@Operation ?:} Concatenates a string and an Any.  If either is null then null is returned.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $ConcatNull(value EString in, rvalue EglAny in) returns(EString) {@Operation{"?:"}};

	/**
	 * {@Operation ?:} Concatenates an Any and a string.  If either is null then null is returned.
	 *
	 * @throws AnyException if the conversion from any to string fails.
	 */
	static function $ConcatNull(value EglAny in, rvalue EString in) returns(EString) {@Operation{"?:"}};

	/**
	 * {@Operation <} Compares two strings.
	 */
	static function $LT(lvalue EString in, rvalue EString in) returns (EBoolean) {@Operation{"<"}};

	/**
	 * {@Operation >} Compares two strings.
	 */
	static function $GT(lvalue EString in, rvalue EString in) returns (EBoolean) {@Operation{">"}};

	/**
	 * {@Operation <=} Compares two strings.
	 */
	static function $LTE(lvalue EString in, rvalue EString in) returns (EBoolean) {@Operation{"<="}};

	/**
	 * {@Operation >=} Compares two strings.
	 */
	static function $GTE(lvalue EString in, rvalue EString in) returns (EBoolean) {@Operation{">="}};

	/**
	 * {@Operation ==} Compares two strings.
	 */
	static function $EQ(lvalue EString in, rvalue EString in) returns(EBoolean) {@Operation{"=="}};

	/**
	 * {@Operation !=} Compares two strings.
	 */
	static function $NEQ(lvalue EString in, rvalue EString in) returns(EBoolean) {@Operation{"!="}};

	/**
	 * {@Operation [:} Returns the substring starting at fromIndex and ending at toIndex.
	 * @throws InvalidIndexException  if either index is out of range, or fromIndex is >= toIndex.
	 */
	static function $Substr(value EString in, fromIndex EInt in, toIndex EInt in) returns(EString) {@Operation{"[:"}};
	
	static function asNumber(value EString in) returns(EglNumber) {@Operation{"narrow"}};
	
	static function asString(value EBigint in) returns (EString) {@Operation{"widen"}};
	static function asString(value EBoolean in) returns (EString) {@Operation{"widen"}};
	
	/**
	 * {@Operation widen} Converts a date to a string in the format "MM/dd/yyyy".
	 * Leading zeros are included in the string, so April 1st in the year 9 A.D. is
	 * converted to "04/01/0009".
	 */
	static function asString(value EDate in) returns (EString) {@Operation{"widen"}};
	static function asString(value EDecimal in) returns (EString) {@Operation{"widen"}};
	static function asString(value EFloat in) returns (EString) {@Operation{"widen"}};
	static function asString(value EInt in) returns (EString) {@Operation{"widen"}};
	static function asString(value ESmallfloat in) returns (EString) {@Operation{"widen"}};
	static function asString(value ESmallint in) returns (EString) {@Operation{"widen"}};
	
	/**
	 * {@Operation widen} Converts a timestamp to a string.  The 26-character result
	 * will include all possible fields of a timestamp, from years down to fractions
	 * of seconds, in the format "yyyy-MM-dd HH:mm:ss.SSSSSS".  Leading zeros are 
	 * included in each field of the string when necessary, e.g. January is 
	 * represented as "01" not "1". 
	 */
	static function asString(value ETimestamp in) returns (EString) {@Operation{"widen"}};
	
	/**
	 * A pattern-matching function which compares this string to a pattern using
	 * the rules of SQL's LIKE operator.  There are three special characters:
	 *   _ matches any one character 
	 *   % matches zero or more characters
	 *   \ is the escape character 
	 *
	 * TODO put more details here
	 *
	 * @param value  the pattern to compare with this string.
	 * @return true if this string matches the pattern.
	 * @throws InvalidPatternException if the pattern is invalid.
	 */
	function isLike(value EString in) returns(EBoolean);

	/**
	 * A pattern-matching function which compares this string to a pattern using
	 * the rules of SQL's LIKE operator.  There are three special characters:
	 *   _ matches any one character 
	 *   % matches zero or more characters
	 *   the escape character from the second parameter 
	 *
	 * TODO put more details here
	 *
	 * @param value  the pattern to compare with this string.
	 * @param esc    the escape character for the pattern.
	 * @return true if this string matches the pattern.
	 * @throws InvalidPatternException if the pattern is invalid.
	 */
	function isLike(value EString in, esc EString in) returns(EBoolean);

	/**
	 * A pattern-matching function which compares this string to a pattern using
	 * the rules of Informix's MATCHES operator.
	 *
	 * TODO put more details here
	 *
	 * @param value  the pattern to compare with this string.
	 * @return true if this string matches the pattern.
	 * @throws InvalidPatternException if the pattern is invalid.
	 */
	function matchesPattern(value EString in) returns(EBoolean);

	/**
	 * A pattern-matching function which compares this string to a pattern using
	 * the rules of Informix's MATCHES operator.
	 *
	 * TODO put more details here
	 *
	 * @param value  the pattern to compare with this string.
	 * @param esc    the escape character for the pattern.
	 * @return true if this string matches the pattern.
	 * @throws InvalidPatternException if the pattern is invalid.
	 */
	function matchesPattern(value EString in, esc EString in) returns(EBoolean);

	function length() returns(EInt);
	function clip() returns(EString);
	function clipLeading() returns(EString);
	function trim() returns(EString);
	function toUpperCase() returns(EString);
	function toLowerCase() returns(EString);
	function indexOf(substr EString in) returns (EInt);
	function indexOf(substr EString in, startIndex EInt in) returns (EInt);
	function lastIndexOf(substr EString in) returns (EInt);
	function endsWith(suffix EString in) returns(EBoolean);
	function startsWith(prefix EString in) returns(EBoolean);
	// replace all occurances of target
	function replaceStr(target EString in, replacement EString in) returns(EString);
	function charCodeAt(index EInt in) returns(EInt);
end
