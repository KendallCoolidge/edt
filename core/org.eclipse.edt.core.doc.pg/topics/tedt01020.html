<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<meta name="DC.Type" content="topic"></meta>
<meta name="DC.Title" content="Creating an Interface type to access a REST service"></meta>
<meta name="abstract" content="You define an EGL Interface type in a file that is made available to the requester of that service. The Interface type can be in the same EGL package or can be imported from a separate package."></meta>
<meta name="description" content="You define an EGL Interface type in a file that is made available to the requester of that service. The Interface type can be in the same EGL package or can be imported from a separate package."></meta>
<meta name="DC.subject" content="Interface types, REST service access, creating interfaces"></meta>
<meta name="keywords" content="Interface types, REST service access, creating interfaces"></meta>
<meta name="DC.Relation" scheme="URI" content="../topics/tedt01002.html"></meta>
<meta name="copyright" content="(C) Copyright 2011, 2012" type="primary"></meta>
<meta name="DC.Rights.Owner" content="(C) Copyright 2011, 2012" type="primary"></meta>
<meta name="DC.Format" content="XHTML"></meta>
<meta name="DC.Identifier" content="tedt01020"></meta>
<meta name="DC.Language" content="en-us"></meta>
<link rel="stylesheet" type="text/css" href="../../org.eclipse.edt.core.doc.top/style/commonltr.css"></link>
<title>Creating an Interface type to access a REST service</title>
</head>
<body id="tedt01020">


<h1 class="title topictitle1">Creating an Interface type to access a REST service</h1>



<div class="body"><p class="shortdesc">You define an EGL Interface type in a file that is made
available to the requester of that service. The Interface type can
be in the same EGL package or can be imported from a separate package.</p>

<p class="p">An EGL
Interface type includes one or more <dfn class="term">function prototypes</dfn>,
which are descriptions of how to write code to access a given service
operation. A function prototype includes the operation name, parameters
(if any), and a return type (if any). The prototype does not include
the logic of the operation, which is available in the service only.</p>

<p class="p">The Interface type of an EGL REST-RPC service is simpler than an
Interface type for a third-party REST service.</p>

<div class="section"><h2 class="title sectiontitle">Interface type for accessing an EGL REST-RPC service</h2><div class="p">This
example shows an Interface type for accessing an EGL REST-RPC service.
The example includes a single function prototype:<pre class="pre codeblock">Interface EmployeeService
   Function GetEmployeeDetail(employeeCode STRING IN, 
                              employeeSalary FLOAT OUT, 
                              employeeStatus STRING INOUT) 
            returns(myEmployeeRecordPart);
end
</pre>
</div>
<p class="p">You can specify various EGL data types and can
use the modifiers IN, OUT, and INOUT.</p>
<div class="p">To create the Interface
type in the IDE: <ol class="ol">
<li class="li">In the Project Explorer view, right-click the EGL file that defines
the service</li>

<li class="li">Click <span class="ph menucascade"><span class="ph uicontrol">EGL Services</span> &gt; <span class="ph uicontrol">Extract
EGL Interface</span></span>.</li>

<li class="li">In the New EGL Interface type window, specify the appropriate
details, and click <span class="ph uicontrol">Finish</span>.</li>

</ol>
</div>
</div>

<div class="section"><h2 class="title sectiontitle">Interface type for accessing a third-party REST service</h2><div class="p">This
example shows Interface type for accessing a third-party REST service:<pre class="pre codeblock">Interface WeatherForecast
   Function GetWeatherByZipCode(zipcode string in) returns(myRecordPart)
      {@GetRest{uriTemplate="/GetWeatherByZipCode?zipCode={zipcode}",
                requestFormat = JSON,
                responseFormat = JSON}};
end</pre>
</div>
<div class="p">If the purpose of the Interface type is to describe
the operations that are available in a third-party REST service (not
an EGL REST-RPC service), you must specify an annotation for each
function prototype. The name of the annotation indicates the HTTP
verb that is used to access the service: <ul class="ul">
<li class="li">For the GET method, the name is <span class="ph synph"><span class="keyword kwd">GetREST</span></span>.</li>

<li class="li">For the POST method, the name is <span class="ph synph"><span class="keyword kwd">PostREST</span></span>.</li>

<li class="li">For the PUT method, the name is <span class="ph synph"><span class="keyword kwd">PutREST</span></span>.</li>

<li class="li">For the DELETE method, the name is <span class="ph synph"><span class="keyword kwd">DeleteREST</span>.</span></li>

</ul>
</div>
<p class="p">Those annotations are called the xREST annotations because
the same three fields are in each, as described in the xREST annotations
section of this topic.</p>
<div class="p">In the service-invocation statement that
is used to access a third-party REST service, the argument that is
passed to a given function parameter has one of two purposes: <ul class="ul">
<li class="li">Usually, the argument provides a value that the requester includes
in the URI. This usage is shown later in this topic, in the description
of the xREST annotations. Those values are not passed to the service
logic; they are values that are embedded in the URI. In particular,
if the annotation is <span class="ph synph"><span class="keyword kwd">GetREST</span></span>, all of the
arguments that are assigned to the function parameters are used to
construct the URI.</li>

<li class="li">In the case of one argument (at most), the argument is a representation
that is processed by the service; for example, a record that contains
values used to create a database-table row. Here are details:<ul class="ul">
<li class="li">If the annotation is <span class="ph synph"><span class="keyword kwd">PostREST</span></span> or <span class="ph synph"><span class="keyword kwd">PutREST</span></span> for
a given operation, the additional argument must be present, and the
related parameter is called the <dfn class="term">representation parameter</dfn>. </li>

<li class="li">The argument also might be required if the annotation is <span class="ph synph"><span class="keyword kwd">DeleteREST</span></span>.
The need for such an argument depends on the service provider. </li>

</ul>
</li>

</ul>
</div>
<div class="p">If the function prototype has a parameter that is not
identified in the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> annotation
field (for <span class="ph synph"><span class="keyword kwd">PostREST</span></span>, <span class="ph synph"><span class="keyword kwd">PutREST</span></span>,
or <span class="ph synph"><span class="keyword kwd">DeleteREST</span></span>), that parameter is a representation
parameter. Either of the following cases is an error:<ul class="ul">
<li class="li">Specifying more than one representation parameter</li>

<li class="li">Specifying a representation parameter when <span class="ph synph"><span class="keyword kwd">GetREST</span></span> is
in use</li>

</ul>
</div>
<p class="p">For restrictions on the arguments sent to a service, see
“Restrictions in the prototypes used for service access.”</p>
<p class="p">You
do not need to create an Interface type. Instead, you can use IRest,
which is an Interface type that is provided for you and that can be
the basis of a variable that is used to access a third-party REST
service. For more information about that Interface type, see <a class="xref" href="tedt01025.html" title="In EGL, you can use the following Interface part to access a third-party REST service:">Using a provided Interface part for a 3rd-party REST service</a>.</p>
</div>

<div class="section"><h2 class="title sectiontitle">xREST annotations used for third-party REST services</h2><p class="p">Each
of the xREST annotations has these fields: <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span>, <span class="ph synph"><span class="keyword kwd">requestFormat</span></span>,
and <span class="ph synph"><span class="keyword kwd">responseFormat</span></span>.</p>
<div class="p"><dl class="dl parml">
<dt class="dt pt dlterm"><span class="ph synph"><span class="keyword kwd">uriTemplate</span></span></dt>

<dd class="dd pd">A string, or <dfn class="term">template</dfn>, that in most cases outlines
a relative URI, which identifies the last qualifiers in the URI that
are used to access the service.<div class="p">The first URI qualifiers are specified
in one of the following ways:<ul class="ul">
<li class="li">When you declare a variable based on the Interface type, you can
identify an entry in a deployment descriptor. In this case, an initial
value for the URI is in the deployment descriptor, and at configuration
time, a code installer can change that value.</li>

<li class="li">You can update the URI at run time, as described in "Binding an
access variable dynamically.”</li>

</ul>
</div>
<p class="p">If you do not set the URI, the value of the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> annotation
field includes the complete URI. In most cases, the value of the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> field
has two aspects:</p>
<ul class="ul">
<li class="li">The value of the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> field can
include a constant value. Those characters are present in or after
every URI that is used to access the function. In the previous example,
the value of <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> includes a query
variable, and the constant value is as follows:<pre class="pre codeblock">   /GetWeatherByZip?zipcode= </pre>
<div class="p">If
the example is changed to include a path variable instead of the query
string, the constant value is as follows:<pre class="pre codeblock">   /GetWeatherByZip/</pre>
</div>
</li>

<li class="li">The value of the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> annotation
can include path variables and query variables. The previous example
includes a single query variable:<pre class="pre codeblock">   {zipcode}</pre>
<div class="p">For
the original example with a query string, here is a relative URI and
value that are used to access the service:<pre class="pre codeblock">/GetWeatherByZip?zipcode=02135</pre>
</div>
<div class="p">If
the template includes a path variable instead of a query string, here
is a relative URI:<pre class="pre codeblock">/GetWeatherByZip/02135</pre>
</div>
<p class="p">The
EGL runtime code automatically completes a URI encoding on each substitution
value that is specified in a service invocation statement, with one
exception. </p>
<p class="p">For example, if your service-invocation statement
indicates that the value for a given substitution variable is "Jeff
Smith", the EGL runtime code converts the string to "Jeff%20Smith"
so that the URI is valid. However, if the value of a substitution
value begins with <em class="ph i">http</em>, the EGL runtime code does no URI encoding
because the service-invocation statement is specifying an argument
that provides a complete URI. If you are responsible for URI encoding,
review the documentation on the <span class="ph synph"><span class="keyword kwd">httpLib.convertToURLEncoded</span></span> system
function.</p>
</li>

</ul>
<p class="p">The default value of the <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> field
is an empty string so that, by default, you can specify the complete
URI by setting the base URI.</p>
</dd>


<dt class="dt pt dlterm"><span class="ph synph"><span class="keyword kwd">requestFormat</span></span></dt>

<dd class="dd pd">A value that indicates the format of the representation that is
sent to the service: <ul class="ul">
<li class="li">XML, to indicate that the format is Extensible Markup Language</li>

<li class="li">NONE, to indicate that the representation is a string, or a value
that is compatible with a string, and is sent as is</li>

<li class="li">JSON, to indicate that the format is JavaScript™ Object Notation</li>

<li class="li">FORM, to indicate that the format is form data, which is a record
composed of argument-value pairs. In the following example of the
content sent to the service, each pair is separated from the next
by an ampersand (&amp;):<pre class="pre codeblock">division=Consumer&amp;dept=Sales</pre>
<div class="p">For
a given field in the Record type that is the basis of form data, you
can specify the <span class="ph synph"><span class="keyword kwd">FormName</span></span> annotation. You
can use that annotation to work with an argument name that is an EGL
reserved word or is not valid in EGL. Here is an example use of the <span class="ph synph"><span class="keyword kwd">FormName</span></span> annotation:<pre class="pre codeblock">record anyRecord
   continue boolean {FormName="continue-content"};
end</pre>
</div>
<div class="p">The runtime code uses the value of the <span class="ph synph"><span class="keyword kwd">FormName</span></span> annotation
as the name of the argument transmitted to the service. Here is a
representation that might be sent to the service: <pre class="pre codeblock">continue-content=yes</pre>
</div>
<p class="p">The
default value of the <span class="ph synph"><span class="keyword kwd">FormName</span></span> annotation
is the name of the record field. In this example, the default is <samp class="ph codeph">continue</samp>.</p>
<p class="p">You
cannot override the value of the <span class="ph synph"><span class="keyword kwd">FormName</span></span> annotation
when you declare a record that is based on the Record type.</p>
</li>

</ul>
<div class="p">If the representation is a record, the following statements
apply:<ul class="ul">
<li class="li">The default value of <span class="ph synph"><span class="keyword kwd">requestFormat</span></span> is <em class="ph i">XML</em>.</li>

<li class="li"><em class="ph i">JSON</em> is also valid.</li>

<li class="li"><em class="ph i">FORM</em> is valid only if every field in the record is of type
STRING or is of a type that is assignment-compatible with STRING. <em class="ph i">FORM</em> is
not valid if the record references another record.</li>

</ul>
</div>
</dd>


<dt class="dt pt dlterm"><span class="ph synph"><span class="keyword kwd">responseFormat</span></span></dt>

<dd class="dd pd">A value that indicates the format of the representation that is
returned to the requester: <ul class="ul">
<li class="li">XML, to indicate that the returned representation is in XML format</li>

<li class="li">NONE, to indicate that the returned representation is a string</li>

<li class="li">JSON, to indicate that the returned representation is in JSON
format</li>

</ul>
<p class="p">If the return value in the Interface type function prototype
is a string or a value that is compatible with a string, the default
value of <span class="ph synph"><span class="keyword kwd">responseFormat</span></span> is <em class="ph i">NONE</em>,
which is the only valid format. If the return value is a record, the
default value of <span class="ph synph"><span class="keyword kwd">responseFormat</span></span> is <em class="ph i">XML</em>,
and <em class="ph i">JSON</em> is also valid.</p>
</dd>

</dl>
</div>
<div class="p">You can specify an <span class="ph synph"><span class="keyword kwd">xREST</span></span> annotation
without assigning values to the annotation fields: <pre class="pre codeblock">Interface IEmployeeService
   Function GetEmployeeDetail() returns(myRecordPart)
      {@GetRest{}};
end</pre>
</div>
<div class="p">The lack of annotation fields indicates these
behaviors:<ul class="ul">
<li class="li">You must provide the complete REST service URI, such as http://www.mycompany.com/myservice,
without providing detail in the Interface type. For information about
the three choices for specifying the base URI, see the description
of <span class="ph synph"><span class="keyword kwd">uriTemplate</span></span> in this topic.</li>

<li class="li">If the representation parameter (or, for the <span class="ph synph"><span class="keyword kwd">GetREST</span></span> annotation,
the return value) is a string, the EGL runtime code does no conversion.
You must handle the conversion and can use any of the following functions
for that purpose: <ul class="ul" compact="compact">
<li class="li">JSONLib.convertFromJSON</li>

<li class="li">JSONLib.convertToJSON</li>

<li class="li">XMLLib.convertFromXML</li>

<li class="li">XMLLib.convertToXML</li>

</ul>
</li>

<li class="li">If the representation parameter is a record, the EGL runtime code
converts the related argument to Extensible Markup Language (XML)
format. </li>

<li class="li">For the <span class="ph synph"><span class="keyword kwd">GetREST</span></span> annotation, if the return
value is a record, the EGL runtime code converts that record from
XML format.</li>

</ul>
.</div>
</div>

</div>

<div class="related-links">
<div class="familylinks">
</div>
</div>

</body>
</html>