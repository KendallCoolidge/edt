/*******************************************************************************
 * Copyright Â© 2011 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * IBM Corporation - initial API and implementation
 *
 *******************************************************************************/
package org.eclipse.edt.gen.javascript;

import java.util.HashMap;
import java.util.Map;

import org.eclipse.edt.compiler.core.IEGLConstants;
import org.eclipse.edt.gen.AbstractGeneratorCommand;
import org.eclipse.edt.gen.EglContext;
import org.eclipse.edt.gen.EGLMessages.EGLMessage;
import org.eclipse.edt.mof.egl.Annotation;
import org.eclipse.edt.mof.egl.Element;
import org.eclipse.edt.mof.egl.Type;

public class Context extends EglContext {

	private static final long serialVersionUID = 6429116299734843162L;

	private String currentFunction;
	private Map<String, String> namespaceMap = new HashMap<String, String>();

	public Context(AbstractGeneratorCommand processor) {
		super(processor);
	}

	public String getCurrentFunction() {
		return currentFunction;
	}

	public void setCurrentFunction(String currentFunction) {
		this.currentFunction = currentFunction;
	}

	public String getRawPrimitiveMapping(String item) {
		return super.getPrimitiveMapping(item);
	}

	public String getRawPrimitiveMapping(Type type) {
		return super.getPrimitiveMapping(type);
	}

	public String getRawNativeImplementationMapping(Type type) {
		return super.getNativeImplementationMapping(type);
	}

	public String getRawNativeInterfaceMapping(Type type) {
		return super.getNativeInterfaceMapping(type);
	}

	public String getNativeImplementationMapping(Type type) {
		return Constants.JSRT_EGL_NAMESPACE + super.getNativeImplementationMapping(type);
	}

	public String getNativeTypeName(Type type) {
		String typeName = getNativeImplementationMapping(type);
		return typeName.substring(typeName.lastIndexOf(".") + 1);
	}

	public void handleValidationError(Element obj) {
		int startLine = 0;
		int startOffset = 0;
		int endLine = 0;
		int endOffset = 0;
		String[] details = new String[] { obj.getEClass().getETypeSignature() };
		Annotation annotation = obj.getAnnotation(IEGLConstants.EGL_LOCATION);
		if (annotation != null) {
			if (annotation.getValue(IEGLConstants.EGL_PARTLINE) != null)
				startLine = ((Integer) annotation.getValue(IEGLConstants.EGL_PARTLINE)).intValue();
			if (annotation.getValue(IEGLConstants.EGL_PARTOFFSET) != null)
				startOffset = ((Integer) annotation.getValue(IEGLConstants.EGL_PARTOFFSET)).intValue();
		}
		EGLMessage message = EGLMessage.createEGLMessage(getMessageMapping(), EGLMessage.EGL_ERROR_MESSAGE, Constants.EGLMESSAGE_MISSING_TEMPLATE_FOR_OBJECT,
			obj, details, startLine, startOffset, endLine, endOffset);
		getMessageRequestor().addMessage(message);
	}

	public void handleValidationError(Annotation obj) {
		String[] details = new String[] { obj.getEClass().getETypeSignature() };
		EGLMessage message = EGLMessage.createEGLMessage(getMessageMapping(), EGLMessage.EGL_ERROR_MESSAGE,
			Constants.EGLMESSAGE_MISSING_TEMPLATE_FOR_ANNOTATION, obj, details, 0, 0, 0, 0);
		getMessageRequestor().addMessage(message);
	}

	public void handleValidationError(Type obj) {
		String[] details = new String[] { obj.getEClass().getETypeSignature() };
		EGLMessage message = EGLMessage.createEGLMessage(getMessageMapping(), EGLMessage.EGL_ERROR_MESSAGE, Constants.EGLMESSAGE_MISSING_TEMPLATE_FOR_TYPE,
			obj, details, 0, 0, 0, 0);
		getMessageRequestor().addMessage(message);
	}

	public void addNamespace(String namespace, String localName, String qualifiedPart) {
		namespaceMap.put(namespace + '{' + localName + '}', qualifiedPart);
	}

	public Map<String, String> getNamespaceMap() {
		return namespaceMap;
	}
	/*
	 * TODO sbg need to revisit support for EGL src line numbers public void gen(String methodName, Annotation type,
	 * EglContext ctx, TabbedWriter out, Object... args) throws TemplateException { updateEGLLocation(type, out);
	 * super.gen(methodName, type, ctx, out, args); } public void gen(String methodName, Classifier part, EglContext ctx,
	 * TabbedWriter out, Object... args) throws TemplateException { updateEGLLocation(part, out); super.gen(methodName, part,
	 * ctx, out, args); } public void gen(String methodName, EObject object, TemplateContext ctx, TabbedWriter out, Object...
	 * args) throws TemplateException { if (object instanceof Element){ updateEGLLocation((Element)object, out); }
	 * super.gen(methodName, object, ctx, out, args); } public void gen(String methodName, Object object, TemplateContext
	 * ctx, TabbedWriter out, Object... args) throws TemplateException { if (object instanceof Element){
	 * updateEGLLocation((Element)object, out); } super.gen(methodName, object, ctx, out, args); } public void gen(String
	 * methodName, Type type, EglContext ctx, TabbedWriter out, Object... args) throws TemplateException {
	 * updateEGLLocation(type, out); super.gen(methodName, type, ctx, out, args); } private void updateEGLLocation(Element
	 * element, TabbedWriter out) { if (out instanceof TabbedReportWriter){ for (Annotation ann : element.getAnnotations()) {
	 * if ("EGL_Location".equals(ann.getEClass().getName())) { // ((TabbedReportWriter)out).location = ann; break; } } } }
	 */
}
