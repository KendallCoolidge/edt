/*******************************************************************************
 * Copyright Â© 2013 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * IBM Corporation - initial API and implementation
 *
 *******************************************************************************/
package expressions;

library numericLiterals
	
	function functionName()
		a any?;
		rec numLitRec;
		
		// Within range
		a = 2147483647; //0
		a = 9223372036854775807I; //0
		a = 32767i; //0
		a = 3.4f; //0
		a = 934.234F; //0
		a = 934.234e34; //0
		a = 12345678901234567890123456789012.; //0
		a = .12345678901234567890123456789012; //0
		a = 1234567890123456.7890123456789012; //0
		rec = new numlitrec{i = 2147483647}; //0
		rec = new numlitrec{i = 9223372036854775807I}; //0
		rec = new numlitrec{i = 32767i}; //0
		rec = new numlitrec{i = 21474.234f}; //0
		rec = new numlitrec{i = 21474.234F}; //0
		rec = new numlitrec{i = 21474.234e22}; //0
		rec = new numlitrec{i = 12345678901234567890123456789012.}; //0
		rec = new numlitrec{i = .12345678901234567890123456789012}; //0
		rec = new numlitrec{i = 1234567890123456.7890123456789012}; //0
		
		
		// Too big
		a = 2147483648; //1
		a = 32768i; //1
		a = 9223372036854775808I; //1
		a = 1000000000000000000000000000000000000000000000.022f; //1
		// double can be huge
		a = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999F; //1
		a = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999e0; //1
		a = .999999999999999999999999999999999; //1
		a = 999999999999999999999999999999999.; //1
		a = 9999999999999999.99999999999999999; //1
		rec = new numlitrec{i = 2147483648}; //1
		rec = new numlitrec{i = 32768i}; //1
		rec = new numlitrec{i = 9223372036854775808I}; //1
		rec = new numlitrec{i = 1000000000000000000000000000000000000000000000.0222f}; //1
		rec = new numlitrec{i = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999F}; //1
		rec = new numlitrec{i = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999e0}; //1
		rec = new numlitrec{i = 12345678901234567890123456789012.3}; //1
		rec = new numlitrec{i = .123456789012345678901234567890123}; //1
		rec = new numlitrec{i = 1234567890123456.78901234567890123}; //1
		
		
		// Can pass to in, can't pass to inout or out
		testin(1010I, 1010, 10i, 324.34f, 324.243F, 6.7); //0
		testinout(1010I, 1010, 10i, 324.34f, 324.243F, 1.1); //6
		testout(1010I, 1010, 10i, 324.34f, 324.243F, 2.3); //6
		
		for (i int from 10I to 20f by 10i) //0
		end
	end
	
	function testin(b bigint in, i int in, si smallint in, sf smallfloat in, f float in, d decimal in) end
	function testinout(b bigint inout, i int inout, si smallint inout, sf smallfloat inout, f float inout, d decimal inout) end
	function testout(b bigint out, i int out, si smallint out, sf smallfloat out, f float out, d decimal out) end
end

record numLitRec{@annotationRec{
	//annotation fields follow different rules. e.g. all integer literals are treated as int, all float literals are float (values too high marked as infinity instead of error), no length limit on decimal
	val1 = 10I, //0
	val1 = 10i, //0
	val1 = 10, //0 
	val2 = 10f, //0
	val2 = 10F, //0
	val3 = 12345678901234567890123456789012., //0
	val3 = .12345678901234567890123456789012, //0
	val3 = 123456789012.34567890123456789012, //0
	val1 = 100000000000000000000000000000I, //2
	val1 = 1000000i, //0
	val1 = 1000000000000, //2
	val2 = 1000000000000000000000000000000000000000000000000000f, //0
	val2 = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999F, //0
	val3 = 12345678901234567890123456789012.3, //0
	val3 = .123456789012345678901234567890123, //0
	val3 = 123456789012345678901234567890123. //0
	}}
	i int;
end

record annotationRec type annotation
	{targets=[RecordPart]}
	val1 int;
	val2 float;
	val3 decimal;
end