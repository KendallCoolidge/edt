/*******************************************************************************
 * Copyright Â© 2012, 2013 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 * IBM Corporation - initial API and implementation
 *
 *******************************************************************************/
//ignore_case

// valid PSBRecord, dliSegments and DataItems to use in statements
DataItem CourseNo char(3) { dliFieldName="COURSE#" } end	 
DataItem EmpNo char(6) { dliFieldName ="EMP#" } end		 
DataItem Name char(18) { dliFieldName ="NAME" } end		 

Record Course type DLISegment 					 
{ segmentName="COURSE", keyItem=courseNo }		 
	10 courseNo CourseNo;							 
	10 title char(33);								  
	10 desc char(220) { dliFieldName="DESCRIPN" };	 
end

Record Prereq type DLISegment { keyItem=courseNo } 
	10 courseNo CourseNo;							 
	10 title char(33);								 
end

Record Offering type DLISegment 					 
	10 offerdate num(6)  { dliFieldName="DATE" };	 
	10 location char(12);							 
	10 format_ char(2) { dliFieldName="FORMAT" };	 
end

Record Teacher type DLISegment 					 
{ segmentName="TEACHER", keyItem=empNo }		 
	10 empNo EmpNo;									 
	10 name Name;									 
end 

Record Student type DLISegment	 				 
	{ segmentName="STUDENT" }						 
	10 empNo EmpNo;									 
	10 name Name;									 
	10 grade char(1);								 
end
Record EducationPSB type PSBRecord 				 
	{defaultPSBName = "EDUCPSB"}					 
	iopcb IO_PCBRecord {@PCB{ pcbType=TP }};		 
 	altpcb ALT_PCBRecord {@PCB{ pcbType=TP }};		 
	coursePCB DB_PCBRecord { @PCB {					 
	  pcbType=DB,									 
	  pcbName="CPCB",								 
	  hierarchy = [									 
	   @Relationship{ segmentRecord=Course },		 
	   @Relationship{											 
     		segmentRecord=Prereq, parentRecord=Course },	    	   
       @Relationship{											 
      		segmentRecord=Offering,parentRecord=Course },  	  
       @Relationship{											 
      		segmentRecord=Teacher,parentRecord=Offering},  
	   @Relationship{											 
	     	segmentRecord=Student, parentRecord=Offering}	 
   ] }};
  offeringPCB DB_PCBRecord { @PCB {				 
	  pcbType=DB,									 
	  pcbName="OPCB",								 
	  secondaryIndex="XLOC",						 
	  hierarchy = [									 
	   @Relationship{ segmentRecord=Offering },	 
	   @Relationship{								 
	     segmentRecord=Course,parentRecord=Offering},	 
	   @Relationship{										 
	     segmentRecord=Teacher,parentRecord=Offering},	 
	   @Relationship{										 
	     segmentRecord=Student,parentRecord=Offering}	 
	  ] }};
end
Record EducationPSB3 type PSBRecord 				 
	{defaultPSBName = "EDUCPSB"}					 
	iopcb IO_PCBRecord {@PCB{ pcbType=TP }};		 
 	altpcb ALT_PCBRecord {@PCB{ pcbType=TP }};		 
	coursePCB DB_PCBRecord { @PCB {					 
	  pcbType=DB,									 
	  pcbName="CPCB",								 
	  hierarchy = [									 
	   @Relationship{ segmentRecord=Course },		 
	   @Relationship{											 
     		segmentRecord=Prereq, parentRecord=Course },	    	   
       @Relationship{											 
      		segmentRecord=Offering,parentRecord=Course },  	  
       @Relationship{											 
      		segmentRecord=Teacher,parentRecord=Offering}	 
   ] }};
  offeringPCB DB_PCBRecord { @PCB {				 
	  pcbType=DB,									 
	  pcbName="OPCB",								 
	  secondaryIndex="XLOC",						 
	  hierarchy = [									 
	   @Relationship{ segmentRecord=Offering },	 
	   @Relationship{								 
	     segmentRecord=Course,parentRecord=Offering}	 
	  ] }};
end
//segments not in DL/I PSB or don't match PSB
Program DLIProgramsShortNamesModifiedSSAs_invalid type textUIProgram 
  { includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes,
  @DLI { psb = psb2, 					 
         handleHardDLIErrors = yes }	 
  }
  course course;						   
  prereq prereq;						 
  offering offering;					 
  teacher teacher;						 
  student student;						 
  courses course[20];					   
  prereqs prereq[5];					 
  offers offering[3];					 
  teachers teacher[5];					 
  students student[25];					   
  xloc char(4);							 

  // PSB Declaration
  psb2 EducationPSB3 ;					 

  	function main()
		addStmt();
		deleteStmt();
		getStmt();
		getForUpdateStmt();
		getNextStmt();
		getNextForUpdateStmt();
		getNextInParentStmt();
		getNextInParentForUpdateStmt(); 
		replaceStmt();
  	end
  	function addStmt()		
  	  add student 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   offering			  			//0
  	  					   student};					//0
  	  add student 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT offering			  			//0
  	  					   student};					//0  
  	  add student 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT offering	};		  			//1 The last SSA in the DL/I call must be for STUDENT
   	  // will use coursePCB	- let's tell them the PCB we are using in case their real problem is that they forgot to say usingPCB
   	  add teacher							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
  	  					   teacher			  			//0
  	  					   offering}; 					//1 The last SSA in the DL/I call must be for TEACHER
  	  add teacher							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
  	  //Not always useful, but valid nonetheless.  Will add teacher under the first offering segment under the 
  	  // specified course 
  	  add teacher							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   teacher};   	  				//0
  	  add teacher							 			//0
  	  		with #dli{ISRT garbage (course# = :course.courseno)//1 garbage is not a segment in the hierarchy of psb2.coursePCB
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
 
 		// FGD I'm open to also having the message The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
 		//     here also.  It's a bit redundant, but if it is more work to suppress it than produce it, then let it happen.
 		//	   I do want the duplicate message regardless.  My rationale is that with a big hierarchy, I might not
 		//	   notice that my real problem is duplication verses matching the PCB. 
  	  add teacher							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
  	  					   course (title >= "abc")		//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call
  	  					   teacher						//0
  	  					   offering						//0
  	  					   teacher};   	 				//1 Multiple SSAs for DL/I Segment teacher found. Only one SSA per DL/I segment is allowed in a DL/I call.
 	 	  // This would be the correct way to code the above statement.	
  	  add teacher										//0 
  	  		with #dli{ISRT course (course# = :course.courseno	//0
  	  						     & title >= "abc")		//0	
  	  					   offering						//0
 	  					   teacher};   	  				//0
 
 
 	 // add segment with another PCB and modified SSAs 
 	  add teacher usingPCB psb2.offeringPCB 		 	//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT offering (XLOC = :XLOC) 		//0
  	  					 teacher};  					//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB 
 	  add teacher usingPCB psb2.offeringPCB 		 	//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT teacher};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB   	 
 	  add teacher usingPCB psb2.offeringPCB 		 	//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT offering (XLOC = :XLOC)}; 		//1 The last SSA in the DL/I call must be for TEACHER	 
 	  add teacher usingPCB psb2.offeringPCB 		 	//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT offering (XLOC = :XLOC) 		//0 
  	  					 teacher						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	  					 course};  						//1 The last SSA in the DL/I call must be for TEACHER 
      add course usingPCB psb2.offeringPCB				//0
      	  with #dli{ISRT garbage (date = "060505")		//1 The segment garbage is not a segment in the hierarchy of psb2.offeringPCB
      	  				 offering};						//1 The last SSA in the DL/I call must be for COURSE
 		// FGD I'm open to also having the message The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
 		//     here also.  It's a bit redundant, but if it is more work to suppress it than produce it, then let it happen.
 		//	   I do want the duplicate message regardless.  My rationale is that with a big hierarchy, I might not
 		//	   notice that my real problem is duplication verses matching the PCB.  
      add course usingPCB psb2.offeringPCB				//0
      	  with #dli{ISRT offering (date = "060505")		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB
      	  				 offering (date = "010205")		//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
      	  				 course};							  				 

	   	  
  // add arrays - should have same set of errors as single segment adds 
  	  add students 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   offering			  			//0
  	  					   student};					//0
  	  add students 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT offering			  			//0
  	  					   student};					//0  
  	  add students 										//1 No PCB in psb2 contains the STUDENT segment
   	  		with #dli{ISRT offering	};		  			//1 The last SSA in the DL/I call must be for STUDENT
   	  // will use coursePCB	- let's tell them the PCB we are using in case their real problem is that they forgot to say usingPCB
   	  add teachers							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
  	  					   teacher			  			//0
  	  					   offering}; 					//1 The last SSA in the DL/I call must be for TEACHER
  	  add teachers							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
  	  //Not always useful, but valid nonetheless.  Will add all teachers under the first offering segment under the 
  	  // specified course 
  	  add teachers							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //0
  	  					   teacher};   	  				//0
  	  add teachers							 			//0
  	  		with #dli{ISRT garbage (course# = :course.courseno)//1 The segment garbage is not a segment in the hierarchy of psb2.coursePCB
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
 
 		// FGD I'm open to also having the message The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
 		//     here also.  It's a bit redundant, but if it is more work to suppress it than produce it, then let it happen.
 		//	   I do want the duplicate message regardless.  My rationale is that with a big hierarchy, I might not
 		//	   notice that my real problem is duplication verses matching the PCB. 
  	  add teachers							 			//0
  	  		with #dli{ISRT course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
  	  					   course (title >= "abc")		//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call
  	  					   teacher						//0
  	  					   offering						//0
  	  					   teacher};   	 				//1 Multiple SSAs for DL/I Segment teacher found. Only one SSA per DL/I segment is allowed in a DL/I call.
 	 	  // This would be the correct way to code the above statement.	
  	  add teachers										//0 
  	  		with #dli{ISRT course (course# = :course.courseno	//0
  	  						     & title >= "abc")		//0	
  	  					   offering						//0
 	  					   teacher};   	  				//0	  	
  	  add teachers 										//0
   	  		with #dli{ISRT course*D (course# = :course.courseno) //3 A qualified SSA cannot follow a D command code|D is not a valid command code for a ISRT call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
  	  					   offering			  			//0
  	  					   teacher};					//0 	  					   
 	  					   				   	    	  
   // add arrays of segment with another PCB and modified  SSAs 
  	  add teachers usingPCB psb2.offeringPCB 	 		//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT offering (XLOC = :XLOC) 		//0
  	  					 teacher};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
   	  add teachers usingPCB psb2.offeringPCB 	 		//1 psb2.offeringPCB does not contain the TEACHER segment
  	      with #dli{ISRT offering (XLOC = :XLOC)};		//1 The last SSA in the DL/I call must be for TEACHER	  					 
  	  add courses usingPCB psb2.offeringPCB 	 		//0
  	      with #dli{ISRT offering (XLOC = :XLOC) 		//0
  	  					 teacher						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
  	  					 course};						//0  	  					 
  	  add courses usingPCB psb2.offeringPCB 	 		//0
  	      with #dli{ISRT garbage (XLOC = :XLOC) 		//1 The segment garbage is not a segment in the hierarchy of psb2.offeringPCB
  	  					 teacher};						//2 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB|The last SSA in the DL/I call must be for COURSE
  	  					 
 		// FGD I'm open to also having the message The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
 		//     here also.  It's a bit redundant, but if it is more work to suppress it than produce it, then let it happen.
 		//	   I do want the duplicate message regardless.  My rationale is that with a big hierarchy, I might not
 		//	   notice that my real problem is duplication verses matching the PCB. 
  	  add courses usingPCB psb2.offeringPCB 	 		//0
  	      with #dli{ISRT offering (XLOC = :XLOC) 		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB
  	      				 offering (xloc = :xloc)		//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
  	  					 course};						//0

  	  					 		   	  
   	// add segments using path calls 
	// This should basically be the same as add of a single segment except that 
	//		- there has to be an ssa for every I/O object	
	// 		- The D command code must be present on the first segment named as a target	
	//		- when there are multiple segments named, you can't leave out intermediate segments.
	//		  You don't have to specify higher or lower segments as targets, but you can't skip any.
	//		  SSAs for higher level segments are optional.
  	  add course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
   	  		with #dli{ISRT course*D 					//0
  	  					   offering			  			//0
  	  					   student};					//0
  	  add course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
   	  		with #dli{ISRT offering*D			  		//1 There must be an SSA for each target of the statement. None found for COURSE
  	  					   student};					//0    
  	  add course, offering, teacher 					//0
   	  		with #dli{ISRT offering*D		  			//1 There must be an SSA for each target of the statement. None found for COURSE
  	  					   teacher};					//0
  	  add course, offering, teacher 					//0
   	  		with #dli{ISRT course						//1 The D command code is required on the SSA for the course segment.
   	  					   offering*D		  			//0
  	  					   teacher};					//0
  	  add offering, teacher 							//0
   	  		with #dli{ISRT course (course# = :course.courseno)	//0
   	  					   offering*D		  			//0
  	  					   teacher};					//0  
  	  // will insert under the current course based upon previous calls					   	  					   
  	  add offering, teacher 							//0
   	  		with #dli{ISRT offering*D		  			//0
  	  					   teacher};					//0 
  	  add course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
   	  		with #dli{ISRT offering	};		  			//3 There must be an SSA for each target of the statement. None found for COURSE|There must be an SSA for each target of the statement. None found for STUDENT|The last SSA in the DL/I call must be for STUDENT
  	  add course, offering, teacher						//0
  	  		with #dli{ISRT course*D 					//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
  	  					   teacher			  			//0
  	  					   offering}; 					//1 The last SSA in the DL/I call must be for TEACHER
  	  add course, offering, teacher						//0
  	  		with #dli{ISRT course*D 					//1 There must be an SSA for each target of the statement. None found for TEACHER
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
  	  add course, offering, teacher						//0
  	  		with #dli{ISRT garbage*D 					//4 There must be an SSA for each target of the statement. None found for COURSE|There must be an SSA for each target of the statement. None found for TEACHER|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
  	  					   offering};   	  			//1 The last SSA in the DL/I call must be for TEACHER
 	  add course, offering, teacher						//0
  	  		with #dli{ISRT course*D 					//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
  	  					   course (title >= "abc")		//2 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.|A qualified SSA cannot follow a D command code.
  	  					   teacher						//0
  	  					   offering						//0
  	  					   teacher};   	 				//1 Multiple SSAs for DL/I Segment teacher found. Only one SSA per DL/I segment is allowed in a DL/I call.
 	 	  // This would be the correct way to code the above statement.	
  	  add course, offering, teacher						//0 
  	  		with #dli{ISRT course*D 					//0	
  	  					   offering						//0
 	  					   teacher};   	  				//0  	
  	  add course, teacher								//1 On an ADD statement with multiple targets, The I/O targets must follow the segment hierarchy in PCB psb2.coursePCB
  	  		with #dli{ISRT course*D 					//0	
 	  					   teacher};   	  				//0   	  					     					   
  	  					   
  	  					   	        
  // add segments using path calls, another PCB, and modified SSAs	
      add offering, teacher usingPCB psb2.offeringPCB   //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
          with #dli{ISRT offering*D (XLOC = :XLOC) 		//1 A qualified SSA cannot follow a D command code	
      	  				 teacher}; 						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
      add offering, teacher usingPCB psb2.offeringPCB   //1 The pcb psb2.offeringPCB does not contain the TEACHER segment.
          with #dli{ISRT teacher}; 						//2 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB|There must be an SSA for each target of the statement. None found for Offering.      	  				 
      add offering, course usingPCB psb2.offeringPCB   	//0
          with #dli{ISRT course}; 						//1 There must be an SSA for each target of the statement. None found for Offering.      	  				 
      add offering, course usingPCB psb2.offeringPCB    //0
          with #dli{ISRT offering   (XLOC = :XLOC) 		//1 The D command code is required on the SSA for the offering segment.	
      	  				 course}; 						//0      	  				 
      add offering, course usingPCB psb2.offeringPCB   	//0
          with #dli{ISRT course*D (XLOC = :XLOC) 		//2  A qualified SSA cannot follow a D command code|The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB
      	  				 offering}; 					//2 The D command code is required on the SSA for the offering segment|The last SSA in the DL/I call must be for Course      	  				 
       add offering, course usingPCB psb2.offeringPCB   //0
          with #dli{ISRT offering*D (XLOC = :XLOC) 		//2 A qualified SSA cannot follow a D command code|The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB
          				 offering   (XLOC = :XLOC) 		//2 A qualified SSA cannot follow a D command code|Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
      	  				 course}; 						//0     	  				 
      	  				 	  
  	end  

  	function deleteStmt() 	
  	// modified SSAs	  
	  delete student  					 				//1 No PCB in psb2 contains the STUDENT segment
	  		with #dli{DLET student};	 				//0
	  delete offering									//0
	  		with #dli{DLET course						//1 Only one SSA is allowed on a DLET call
	  					   offering};					//0
	  delete offering									//0
	  		with #dli{DLET course};						//1 The last SSA in the DL/I call must be for Offering
	  delete teacher usingPCB psb2.offeringPCB 			//1 psb2.offeringPCB does not contain the TEACHER segment
	  	  		with #dli{DLET teacher};	 			//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	  delete offering usingPCB psb2.offeringPCB 		//0
	  	  		with #dli{DLET teacher};	 			//2 The last SSA in the DL/I call must be for Offering|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	  delete course usingPCB psb2.offeringPCB			//0
	  			with #dli{DLET offering					//1 Only one SSA is allowed on a DLET call
	  						   course};		  			//0
  	end 	

 	function getStmt() 
    // get segment with no modifiers and modified SSAs	
		get student 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU course (course# = :course.courseno)  	//0
					     offering						//0	 
					     student   };					//0  
		get student 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU offering						//0	 
					     student   };					//0 
		get student 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU course (course# = :course.courseno)  	//0
					     offering  };					//1 The last SSA in the DL/I call must be for STUDENT  	
		//I'm picturing the logic this way:
		//  1 find the PCB
		//  2 look for an SSA to match each level of hierarchy in that PCB (get by key requires every level to be there!)
		//	3 ensure proper order of SSA to PCB hierarchy
		//  4 look for any extraneous SSAs and duplicate segments
		//  5 Items 2 and 3 will together eliminate the need to issue "last SSA must be for target segment" 
		get teacher 									//0 
			with #dli{GU offering						//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for course is missing.
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for offering is missing.
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for TEACHER is missing 
					     offering	 };					//1 The last SSA in the DL/I call must be for TEACHER
  		get teacher 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     teacher (emp# = :teacher.empno)		//0
					     offering	 };					//1 The last SSA in the DL/I call must be for TEACHER
		get teacher 									//0	 
			with #dli{GU garbage (course# = :course.courseno)  //2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for COURSE is missing|The segment garbage is not a segment in the hierarchy of psb2.coursePCB
					     offering						//0 
					     teacher (emp# = :teacher.empno) };		//0
		get teacher 									//0 
			with #dli{GU course (course# = :course.courseno)   //0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     offering						//0 
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher 									//0 
			with #dli{GU course (course# = :course.courseno)   //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//0 
					     teacher (emp# = :teacher.empno) };		//0						     			     					     		     
    // get segment with another PCB and modified SSAs	
		get student usingPCB psb2.offeringPCB  			//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  offering (XLOC = :XLOC)	 	//0
						  student };				 	//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get student usingPCB psb2.offeringPCB  			//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  student };				 	//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB						  
		get student usingPCB psb2.offeringPCB  			//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  offering (XLOC = :XLOC) };	//1 The last SSA in the DL/I call must be for STUDENT
		get course usingPCB psb2.offeringPCB  			//0
			with #dli{GU  course (course# = :course.courseno)};//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for offering is missing.						  
		get course usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 }; //2 The last SSA in the DL/I call must be for COURSE|The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for COURSE is missing
		get course usingPCB psb2.offeringPCB  			//0
			with #dli{GU  course (course# = :course.courseno)  //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  offering (XLOC = :XLOC)	 }; //1 The last SSA in the DL/I call must be for COURSE
		get course usingPCB psb2.offeringPCB  			//0
		with #dli{GU  offering (XLOC = :XLOC)		 	//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB
						  garbage (course# = :course.courseno)};//2 The last SSA in the DL/I call must be for COURSE|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB
		get course usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 	//0
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						  course (course# = :course.courseno)};//0
		get course usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  course (title >"defg")		//0
						  course (course# = :course.courseno)};//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
   	
  	// get arrays of segments with no modifiers and modified SSAs
  	// For get by key for arrays, I am assuming all of the same rules/messages as for 
  	// the get by key for a single segment with the additional validation for the second DL/I call	
		get students 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU course (course# = :course.courseno)  	//0
					     offering						//0 
					     student    					//0 
					  GN teacher			 };			//1 The last SSA in the DL/I call must be for STUDENT
		get students 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU offering						//0	 
					     student    					//0 
					  GN student			 };			//0 
		get students 									//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GU course (course# = :course.courseno)  	//0
					     offering   					//1 The last SSA in the DL/I call must be for STUDENT
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 student			 };			//0 
		get teachers 									//0 
			with #dli{GU offering						//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for course is missing.
					     teacher (emp# = :teacher.empno)   		//0	
					  GN teacher			 };			//0    
		get teachers 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for offering is missing.
					     teacher (emp# = :teacher.empno)   		//0	
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 student			 };			//2 The last SSA in the DL/I call must be for TEACHER|The segment student is not a segment in the hierarchy of psb2.coursePCB
		get teachers 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for TEACHER is missing 
					     offering	  					//1 The last SSA in the DL/I call must be for TEACHER
					  GN student			 };			//2 The last SSA in the DL/I call must be for TEACHER|The segment student is not a segment in the hierarchy of psb2.coursePCB
  		get teachers 									//0 
			with #dli{GU course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     teacher (emp# = :teacher.empno)		//0
					     offering	   					//1 The last SSA in the DL/I call must be for TEACHER	
					  GN teacher			 };			//0
		get teachers 									//0	 
			with #dli{GU garbage (course# = :course.courseno)  //2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for COURSE is missing|The segment garbage is not a segment in the hierarchy of psb2.coursePCB
					     offering						//0 
					     teacher (emp# = :teacher.empno)   		//0	
					  GN teacher			 };			//0
		get teachers 									//0 
			with #dli{GU course (course# = :course.courseno)   //0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     offering						//0 
					     teacher (emp# = :teacher.empno)   		//0	
					  GN student			 };			//2 The last SSA in the DL/I call must be for TEACHER|The segment student is not a segment in the hierarchy of psb2.coursePCB
		get teachers 									//0 
			with #dli{GU course (course# = :course.courseno)   //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//0 
					     teacher (emp# = :teacher.empno)   		//0	
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 student			 };			//2 The last SSA in the DL/I call must be for TEACHER|The segment student is not a segment in the hierarchy of psb2.coursePCB
		get teachers 									//0 
			with #dli{GU course*d (course# = :course.courseno) //2 D is not a valid command code for a GU call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the course segment
					     offering						//0 
					     teacher (emp# = :teacher.empno)   		//0	
					  GN teacher			 };						  	 
 
   // get arrays of segment with another PCB and modified SSAs	 
		get students usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  offering (XLOC = :XLOC)	 	//0
						  student  					 	//The segment student is not a segment in the hierarchy of psb2.offeringPCB
					  GN teacher			 };			//2 The last SSA in the DL/I call must be for STUDENT|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get students usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  student  					 	//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 student			 };			//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 						  
		get students usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GU  offering (XLOC = :XLOC)  		//1 The last SSA in the DL/I call must be for STUDENT
					  GN  student };	  				//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB	
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  course (course# = :course.courseno)  //1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for offering is missing.						  
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 course			 };				//0	
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	    //2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB|The last SSA in the DL/I call must be for COURSE
					  GN student			 };			//2 The last SSA in the DL/I call must be for COURSE|The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  course (course# = :course.courseno)  //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  offering (XLOC = :XLOC)	 	//1 The last SSA in the DL/I call must be for COURSE
					  GN  course };		  				//0
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 	//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for COURSE is missing
						  garbage (course# = :course.courseno) //2 The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|The last SSA in the DL/I call must be for COURSE
					  GN  course };		  				//0				  
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 	//0
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						  course (course# = :course.courseno)  //0
					  GN  teacher };		  			//2 The last SSA in the DL/I call must be for COURSE | The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get courses usingPCB psb2.offeringPCB  			//0
			with #dli{GU  offering (XLOC = :XLOC)	 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  course (title >"defg")		//0 
						  course (course# = :course.courseno)  //1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					  GN offering 						//1 Only one SSA is allowed for the second DL/I call when the target of the get by key statement is an array.
					  	 course			 };				//0
	    // get segments using path calls and modified SSAs	
		get course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GU course*D (course# = :course.courseno) //0 
					     offering						//1 The D command code is required on the SSA for the offering segment 
					     student   };					//0
		get course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GU course*D (course# = :course.courseno) //1 There must be an SSA for each target of the statement. None found for Offering
					     student   };					//0
		get course, offering, student 					//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GU course*D (course# = :course.courseno) //1 There must be an SSA for each target of the statement. None found for STUDENT
					     offering	};					//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment     					     
		get offering, teacher 					 		//0
			with #dli{GU offering*D						//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for course is missing.
					     teacher (emp# = :teacher.empno) };		//0
		//I'm OK if you want to suppress one or the other of these messages
		get course, offering, teacher 					//0
			with #dli{GU course*D (course# = :course.courseno) //2The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for Offering is missing|There must be an SSA for each target of the statement. None found for Offering
					     teacher (emp# = :teacher.empno) };		//0
		get course, offering, teacher 					//0
			with #dli{GU course*D (course# = :course.courseno)	//2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB|There must be an SSA for each target of the statement. None found for TEACHER   
					     offering				 };		//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get course, offering, teacher 					//0
			with #dli{GU course*D (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 		//0
					     offering	 };					//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get course, offering, teacher 					//0
			with #dli{GU garbage*D (course# = :course.courseno)//4 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for COURSE is missing|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|There must be an SSA for each target of the statement. None found for COURSE|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0	
		get course, offering, teacher 					//0
			with #dli{GU course*D (course# = :course.courseno) //0
					     offering						//1The D command code is required on the SSA for the offering segment
					     extra							//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher (emp# = :teacher.empno) };		//0
		get course, offering, teacher 					//0
			with #dli{GU course (course# = :course.courseno)   //2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB|The D command code is required on the SSA for the course segment
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0
   // get segments using path calls, another PCB, and modified SSAs
		get offering, student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GU  offering*D (XLOC = :XLOC)		//0
						  student };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get offering, student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GU  offering*D (XLOC = :XLOC)		//1 There must be an SSA for each target of the statement
						  course };						//1 The last SSA in the DL/I call must be for STUDENT						  
		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GU  teacher (emp# = :teacher.empno)};		//2 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB|There must be an SSA for each target of the statement. None found for Offering
		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GU  offering*D (XLOC = :XLOC)	};	//2 There must be an SSA for each target of the statement. None found for TEACHER|The last SSA in the DL/I call must be for TEACHER
		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GU  teacher (emp# = :teacher.empno)		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};	//1 The last SSA in the DL/I call must be for TEACHER
		
		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GU  garbage*D (XLOC = :XLOC)		//3 The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|There must be an SSA for each target of the statement. None found for Offering|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GU  offering*D (XLOC = :XLOC)		//0
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get offering, teacher usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GU  offering*D (XLOC = :XLOC)		//0
						  teacher (emp# = :teacher.empno)		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};		//2 Multiple SSAs for DL/I Segment teacher found|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	end  
	
 	function getForUpdateStmt() 
		get student forupdate 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHU course (course# = :course.courseno)  //0
					     offering						//0	 
					     student   };					//0  
		get student forupdate 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHU offering						//0	 
					     student   };					//0 
		get student forupdate 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHU course (course# = :course.courseno)  //0
					     offering  };					//1 The last SSA in the DL/I call must be for STUDENT  	
		get teacher forupdate 							//0 
			with #dli{GHU offering						//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for course is missing.
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher forupdate 							//0 
			with #dli{GHU course (course# = :course.courseno) 	//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for offering is missing.
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher forupdate 							//0 
			with #dli{GHU course (course# = :course.courseno) 	//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for TEACHER is missing 
					     offering	 };					//1 The last SSA in the DL/I call must be for TEACHER
  		get teacher forupdate							//0 
			with #dli{GHU course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     teacher (emp# = :teacher.empno)		//0
					     offering	 };					//1 The last SSA in the DL/I call must be for TEACHER
		get teacher forupdate 							//0
			with #dli{GHU garbage (course# = :course.courseno) //2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for COURSE is missing|The segment garbage is not a segment in the hierarchy of psb2.coursePCB
					     offering						//0 
					     teacher (emp# = :teacher.empno) };		//0
		get teacher forupdate 							//0 
			with #dli{GHU course (course# = :course.courseno)  //0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     offering						//0 
					     teacher (emp# = :teacher.empno) };		//0	
		get teacher forupdate 							//0 
			with #dli{GHU course (course# = :course.courseno)  //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//0 
					     teacher (emp# = :teacher.empno) };		//0							   
   // get segment with another PCB and modified SSAs	
		get student forupdate usingPCB psb2.offeringPCB //1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GHU  offering (XLOC = :XLOC)	 	//0
						  student };				 	//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get student forupdate usingPCB psb2.offeringPCB //1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GHU  student };				 	//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB						  
		get student forupdate usingPCB psb2.offeringPCB //1 psb2.offeringPCB does not contain the STUDENT segment 
			with #dli{GHU  offering (XLOC = :XLOC) };	//1 The last SSA in the DL/I call must be for STUDENT
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  course (course# = :course.courseno)};//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for offering is missing.						  
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  offering (XLOC = :XLOC)	 }; //2 The last SSA in the DL/I call must be for COURSE|The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  offering (XLOC = :XLOC)	 }; //1 The last SSA in the DL/I call must be for COURSE						  
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  offering (XLOC = :XLOC)		//1 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.offeringPCB.  The SSA for COURSE is missing
						  garbage (course# = :course.courseno)};//2 The last SSA in the DL/I call must be for COURSE|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  offering (XLOC = :XLOC)	 	//0
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						  course (course# = :course.courseno)};//0
		get course forupdate usingPCB psb2.offeringPCB  //0
			with #dli{GHU  offering (XLOC = :XLOC)	 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						  course (title >"defg")		//0 
						  course (course# = :course.courseno)};//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
   	

	    // get segments using path calls and modified SSAs	
		get course, offering, student forupdate 		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GHU course*D (course# = :course.courseno)//0 
					     offering						//1 The D command code is required on the SSA for the offering segment 
					     student   };					//0
		get course, offering, student forupdate 		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHU course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for Offering 
					     student   };					//0
		get course, offering, student forupdate 		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHU course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for STUDENT 
					     offering	};					//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment
		get offering, teacher forupdate 		 		//0
			with #dli{GHU offering*D					//1 get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for course is missing.
					     teacher (emp# = :teacher.empno) };		//0
		//I'm OK if you want to suppress one or the other of these messages
		get course, offering, teacher forupdate 		//0
			with #dli{GHU course*D (course# = :course.courseno)//2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for Offering is missing|There must be an SSA for each target of the statement. None found for Offering
					     teacher (emp# = :teacher.empno) };		//0
		get course, offering, teacher forupdate 		//0
			with #dli{GHU course*D (course# = :course.courseno)//2 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB.  The SSA for TEACHER is missing|There must be an SSA for each target of the statement. None found for TEACHER
					     offering				 };		//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get course, offering, teacher forupdate 		//0
			with #dli{GHU course*D (course# = :course.courseno)//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 		//0
					     offering	 };					//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get course, offering, teacher forupdate 		//0
			with #dli{GHU garbage*D (course# = :course.courseno)//4 The get by key statement requires an SSA for each segment from the root to the target in the hierarchy in PCB psb2.coursePCB|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|There must be an SSA for each target of the statement. None found for COURSE|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0	
		get course, offering, teacher forupdate 		//0
			with #dli{GHU course*D (course# = :course.courseno)//0
					     offering						//1 The D command code is required on the SSA for the offering segment
					     extra							//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher (emp# = :teacher.empno) };		//0
		get course, offering, teacher forupdate 		//0
			with #dli{GHU course (course# = :course.courseno)  //2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB|The D command code is required on the SSA for the course segment
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0
   // get segments using path calls, another PCB, and modified SSAs
		get offering, student forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHU  offering*D (XLOC = :XLOC)	//0
						  student };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get offering, student forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHU  offering*D (XLOC = :XLOC)	//1 There must be an SSA for each target of the statement. None found for STUDENT
						  course };						//1 The last SSA in the DL/I call must be for STUDENT						  
		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHU  teacher (emp# = :teacher.empno)};	//2 There must be an SSA for each target of the statement. None found for Offering|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHU  offering*D (XLOC = :XLOC)	};	//2 The last SSA in the DL/I call must be for TEACHER|There must be an SSA for each target of the statement. None found for TEACHER
		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHU  teacher (emp# = :teacher.empno)		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};	//1 The last SSA in the DL/I call must be for TEACHER
		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHU  garbage*D (XLOC = :XLOC)		//3 There must be an SSA for each target of the statement. None found for Offering.|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHU  offering*D (XLOC = :XLOC)	//0
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER 
			with #dli{GHU  offering*D (XLOC = :XLOC)	//0
						  teacher (emp# = :teacher.empno)		//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};		//2 Multiple SSAs for DL/I Segment teacher found|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	end 
 	  
 	function getNextStmt() 
 		// It's OK to leave out intervening segments on a Get next call.
 		// If they are there, they have to be correct (right order, target is last one, etc).
 		// Technically, unless the SSA is qualified, is for the target, or has command codes, it is ignored. 	
		get next student						 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN student			 };	 		//0
		get next student						 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student   };					//0 		
		get next student						 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN offering						//0	 
					     student   };					//0 		
		get next student						 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     offering   };					//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next teacher 								//0 
			with #dli{GN course (course# = :course.courseno) 	//0
						 offering						//0
					     teacher };						//0
  		get next teacher 								//0 
			with #dli{GN course 					 	//0
						 offering						//0
					     teacher };						//0
  		get next teacher 								//0 
			with #dli{GN offering						//0
					     teacher };						//0
  		get next teacher 								//0 
			with #dli{GN teacher };						//0
  		get next teacher 								//0 
			with #dli{GN course (course# = :course.courseno) 	//0
						 teacher };						//0	
  		get next teacher 								//0 
			with #dli{GN course }; 					 	//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher 								//0 
			with #dli{GN offering						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (course# = :course.courseno) 	//0
					     teacher };						//0
  		get next teacher 								//0 
			with #dli{GN course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher						//0
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
  		get next teacher 								//0 
			with #dli{GN teacher						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher 								//0 
			with #dli{GN teacher 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course };						//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher 								//0 
			with #dli{GN course 					 	//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
						 offering						//0
					     teacher };						//0
  		get next teacher 								//0
			with #dli{GN offering						//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher };						//0
 		get next teacher 								//0 
			with #dli{GN course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 course (course# = :course.courseno) 	//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0
  		get next teacher 								//0 
			with #dli{GN course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0 
						 offering						//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0

    // get segment with another PCB and modified SSAs
		get next student usingPCB psb2.offeringPCB 	 		//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN student			 };	 		//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next student usingPCB psb2.offeringPCB 			//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student   };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next student usingPCB psb2.offeringPCB 	 		//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN offering						//0	 
					     student   };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next student usingPCB psb2.offeringPCB 	 		//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     offering   };					//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next course usingPCB psb2.offeringPCB 		//0 
			with #dli{GN offering (XLOC = :XLOC)	 	//0
						  course  };					//0
  		get next course usingPCB psb2.offeringPCB 		//0 
			with #dli{GN course 						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};		//1 The last SSA in the DL/I call must be for Course
  		get next course usingPCB psb2.offeringPCB 		//0 
			with #dli{GN offering (XLOC = :XLOC) 		//0
						extra	 						//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};						//0
  		get next course usingPCB psb2.offeringPCB 		//0 
			with #dli{GN  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};						//0
  		get next course usingPCB psb2.offeringPCB 		//0 
			with #dli{GN  offering (XLOC = :XLOC) 		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 		//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
						course};						//0

  	// get arrays of segments with no modifiers and modified SSAs	
		get next students 								//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     offering						//0 
					     student    		 };			//0
		get next students 								//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student    		 };			//0	
		get next students 								//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN offering						//0 
					     student    		 };			//0	
		get next students 								//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student						//0 
					     offering    		 };			//1 The last SSA in the DL/I call must be for STUDENT
		get next teachers 								//0 
			with #dli{GN course (course# = :course.courseno) 	//0
					     offering						//0 
					     teacher  };					//0
		get next teachers 								//0 
			with #dli{GN course (course# = :course.courseno) 	//0
				     teacher  };						//0	
		get next teachers 								//0 
			with #dli{GN teacher  };					//0
		get next teachers 								//0 
			with #dli{GN offering						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB. 
						course (course# = :course.courseno) 	//0
					     teacher  };					//0
		get next teachers 								//0 
			with #dli{GN garbage (course# = :course.courseno) 	//1  garbage is not a segment in the hierarchy of psb2.coursePCB
					     offering						//0 
					     teacher  };					//0
		get next teachers 								//0 
			with #dli{GN course (course# = :course.courseno) 	//0
						extra							//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     offering						//0 
					     teacher  };					//0
		get next teachers 								//0 
			with #dli{GN course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						course							//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     offering						//0 
					     teacher  };					//0
		// The D command code is invalid because it's presence would require that multiple segments be
		// listed as I/O objects.  But, you can't specify multiple targets when one is an array.
		get next teachers 								//0 
			with #dli{GN course*d  						//2 D is not a valid command code for a GN call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the course segment
					     offering						//0 
					     teacher 		 };	

    // get arrays of segments with another PCB and modified SSAs
		get next students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     offering						//0 
					     student    		 };			//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 
		get next students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student    		 };			//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB	
		get next students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN offering						//0 
					     student    		 };			//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB	
		get next students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN course (course# = :course.courseno)  	//0
					     student						//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 
					     offering    		 };			//1 The last SSA in the DL/I call must be for STUDENT
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN offering (XLOC = :XLOC)	 	//0
						  course  };					//0
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN course 						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};		//1 The last SSA in the DL/I call must be for Course
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN offering (XLOC = :XLOC) 		//0
						extra	 						//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};						//0
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN  extra							//1 The segment extra is not a segment in the hierarchy of psb2.offeringPCB
						course};						//0
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN  offering (XLOC = :XLOC) 		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 		//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
						course};						//0
  		get next courses usingPCB psb2.offeringPCB 		//0 
			with #dli{GN offering*d (XLOC = :XLOC)	 	//2 D is not a valid command code for a GN call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment
						  course  };					//0
   
    // get segments using path calls and modified SSAs
		get next course, offering, student 				//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GN course*D (course# = :course.courseno)	//0 
					     offering						//1 The D command code is required on the SSA for the offering segment 
					     student   };					//0
		get next course, offering, student 				//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GN course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for Offering 
					     student   };					//0
		get next course, offering, student 				//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GN course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for STUDENT 
					     offering	};					//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment
		get next offering, teacher 		 				//0
			with #dli{GN offering*D						//0
					     teacher  };					//0
		get next course, offering, teacher 				//0
			with #dli{GN course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for Offering
					     teacher };						//0
		get next course, offering, teacher 				//0
			with #dli{GN course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for TEACHER  
					     offering				 };		//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next course, offering, teacher 				//0
			with #dli{GN course*D (course# = :course.courseno)	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 		//0
					     offering	 };					//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next course, offering, teacher 				//0
			with #dli{GN garbage*D (course# = :course.courseno)//3 There must be an SSA for each target of the statement. None found for COURSE|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering						//1 The D command code is required on the SSA for the offering segment
					     teacher  };					//0	
		get next course, offering, teacher 				//0
			with #dli{GN course*D (course# = :course.courseno)	//0
					     offering						//1 The D command code is required on the SSA for the offering segment
					     extra							//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher  };					//0
		get next course, offering, teacher 				//0
			with #dli{GN course (course# = :course.courseno)  	//2 The D command code is required on the SSA for the course segment|The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0
	 			
    // get segments using path calls, another PCB, and modified SSAs
   		get next offering, student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN  offering*D (XLOC = :XLOC)			//0
						  student };						//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next offering, student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GN  offering*D (XLOC = :XLOC)			//1 There must be an SSA for each target of the statement. None found for STUDENT
						  course };							//1 The last SSA in the DL/I call must be for STUDENT						  
		get next offering, teacher usingPCB psb2.offeringPCB//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GN  teacher (emp# = :teacher.empno)};			//2 There must be an SSA for each target of the statement. None found for Offering|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get next offering, teacher usingPCB psb2.offeringPCB//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GN  offering*D (XLOC = :XLOC)	};		//2 There must be an SSA for each target of the statement|The last SSA in the DL/I call must be for TEACHER
		get next offering, teacher usingPCB psb2.offeringPCB//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GN  teacher (emp# = :teacher.empno)			//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};		//1 The last SSA in the DL/I call must be for TEACHER
		get next offering, teacher usingPCB psb2.offeringPCB//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GN  garbage*D (XLOC = :XLOC)			//3 There must be an SSA for each target of the statement|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};			//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get next offering, teacher usingPCB psb2.offeringPCB//The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GN  offering*D (XLOC = :XLOC)			//0
						  extra								//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};			//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get next offering, teacher usingPCB psb2.offeringPCB//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GN  offering*D (XLOC = :XLOC)			//0 
						  teacher (emp# = :teacher.empno)			//1  The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};			//2 Multiple SSAs for DL/I Segment teacher found|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	end   

 	function getNextForUpdateStmt() 
		get next student forupdate						 	//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHN  student			 };	 			//0
		get next student forupdate						 	//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHN  course (course# = :course.courseno)  	//0
					     student   };						//0 		
		get next student forupdate						 	//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHN  offering							//0	 
					     student   };						//0 		
		get next student forupdate						 	//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHN  course (course# = :course.courseno)  	//0
					     offering   };						//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next teacher forupdate						//0 
			with #dli{GHN  course (course# = :course.courseno) //0
						 offering						//0
					     teacher };						//0
  		get next teacher forupdate						//0 
			with #dli{GHN  course 					 	//0
						 offering						//0
					     teacher };						//0
  		get next teacher forupdate 						//0 
			with #dli{GHN  offering						//0
					     teacher };						//0
  		get next teacher forupdate						//0 
			with #dli{GHN  teacher };					//0
  		get next teacher forupdate						//0 
			with #dli{GHN  course (course# = :course.courseno) //0
						 teacher };						//0	
  		get next teacher forupdate						//0 
			with #dli{GHN  course }; 					//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher forupdate						//0 
			with #dli{GHN  offering						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (course# = :course.courseno) 	//0
					     teacher };						//0
  		get next teacher forupdate						//0 
			with #dli{GHN  course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher						//0
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
  		get next teacher forupdate						//0 
			with #dli{GHN  teacher						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher forupdate						//0 
			with #dli{GHN  teacher 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course };						//1 The last SSA in the DL/I call must be for TEACHER
 		get next teacher forupdate						//0 
			with #dli{GHN  course 					 	//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
						 offering						//0
					     teacher };						//0
  		get next teacher forupdate						//0
			with #dli{GHN  offering						//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher };						//0
 		get next teacher forupdate						//0 
			with #dli{GHN  course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 course (course# = :course.courseno) 	//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0
  		get next teacher forupdate						//0 
			with #dli{GHN  course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 offering						//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0

    // get segment with another PCB and modified SSAs
		get next student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  student			 };	 				//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  course (course# = :course.courseno)  		//0
					     student   };							//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  offering								//0	 
					     student   };							//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  course (course# = :course.courseno)  		//0
					     offering   };							//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next course forupdate usingPCB psb2.offeringPCB //0 
			with #dli{GN offering (XLOC = :XLOC)	 		//1 The get by position statement with the forupdate modifier requires the GHN function code
						  course  };						//0
  		get next course forupdate usingPCB psb2.offeringPCB //0 
			with #dli{GHN  course 							//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};			//1 The last SSA in the DL/I call must be for Course
  		get next course forupdate usingPCB psb2.offeringPCB //0 
			with #dli{GHN  offering (XLOC = :XLOC) 			//0
						extra	 							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};							//0
  		get next course forupdate usingPCB psb2.offeringPCB //0 
			with #dli{GHN  extra							//1 The segment extra is not a segment in the hierarchy of psb2.offeringPCB
						course};							//0
  		get next course forupdate usingPCB psb2.offeringPCB //0 
			with #dli{GHN  offering (XLOC = :XLOC) 			//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 			//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
							course};						//0
   // get segments using path calls and modified SSAs
		get next course, offering, student forupdate		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GHN  course*D (course# = :course.courseno)	//0 
					     offering							//1 The D command code is required on the SSA for the offering segment 
					     student   };						//0
		get next course, offering, student forupdate		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHN  course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for Offering 
					     student   };						//0
		get next course, offering, student forupdate		//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHN  course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for STUDENT 
					     offering	};						//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment
		get next offering, teacher forupdate		 		//0
			with #dli{GHN  offering*D						//0
					     teacher  };						//0
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for Offering
					     teacher };							//0
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  course*D (course# = :course.courseno)	//1 There must be an SSA for each target of the statement. None found for TEACHER  
					     offering				 };			//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  course*D (course# = :course.courseno)	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 			//0
					     offering	 };						//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  garbage*D (course# = :course.courseno)	//3 There must be an SSA for each target of the statement|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering							//1 The D command code is required on the SSA for the offering segment
					     teacher  };						//0	
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  course*D (course# = :course.courseno)	//0
					     offering							//1 The D command code is required on the SSA for the offering segment
					     extra								//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher  };						//0
		get next course, offering, teacher forupdate		//0
			with #dli{GHN  course (course# = :course.courseno) 	//2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB|The D command code is required on the SSA for the course segment
						 course (title > "abc")				//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering							//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };			//0
	 			
    // get segments using path calls, another PCB, and modified SSAs
   		get next offering, student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  offering*D (XLOC = :XLOC)					//0
						  student };									//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next offering, student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHN  offering*D (XLOC = :XLOC)					//1 There must be an SSA for each target of the statement. None found for STUDENT
						  course };										//1 The last SSA in the DL/I call must be for STUDENT						  
		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHN  teacher (emp# = :teacher.empno)};					//2 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB|There must be an SSA for each target of the statement. None found for Offering
		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHN  offering*D (XLOC = :XLOC)	};				//2 There must be an SSA for each target of the statement. None found for TEACHER|The last SSA in the DL/I call must be for TEACHER
		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHN  teacher (emp# = :teacher.empno)						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};					//1 The last SSA in the DL/I call must be for TEACHER
		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHN  garbage*D (XLOC = :XLOC)						//3 There must be an SSA for each target of the statement. None found for Offering|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHN  offering*D (XLOC = :XLOC)					//0
						  extra											//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get next offering, teacher forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHN  offering*D (XLOC = :XLOC)					//0
						  teacher (emp# = :teacher.empno)						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};						//2 Multiple SSAs for DL/I Segment teacher found|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	end 

 	function getNextInParentStmt() 
	// It's dangerous but valid to specify every level of segment in the hierarchy.
	// Since we don't know where parentage is set, there is nothing additional we can check.
		get next inparent student				 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP student			 };	 		//0
		get next inparent student				 		//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP course (course# = :course.courseno) 	//0
					     student   };					//0 		
		get next inparent student						//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP offering						//0	 
					     student   };					//0 		
		get next inparent student						//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  //0
					     offering   };					//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next inparent teacher 						//0 
			with #dli{GNP course (course# = :course.courseno) 	//0
						 offering						//0
					     teacher };						//0
  		get next inparent teacher 						//0 
			with #dli{GNP course 					 	//0
						 offering						//0
					     teacher };						//0
  		get next inparent teacher 						//0 
			with #dli{GNP offering						//0
					     teacher };						//0
  		get next inparent teacher 						//0 
			with #dli{GNP teacher };					//0
  		get next inparent teacher 						//0 
			with #dli{GNP course (course# = :course.courseno) 	//0
						 teacher };						//0	
  		get next inparent teacher 						//0 
			with #dli{GNP course }; 					//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher 						//0 
			with #dli{GNP offering						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (course# = :course.courseno) 	//0
					     teacher };						//0
  		get next inparent teacher 						//0 
			with #dli{GNP course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher						//0
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
  		get next inparent teacher 						//0 
			with #dli{GNP teacher						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher 						//0 
			with #dli{GNP teacher 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course };						//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher 						//0 
			with #dli{GNP course 					 	//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
						 offering						//0
					     teacher };						//0
  		get next inparent teacher 						//0
			with #dli{GNP offering						//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher };						//0
 		get next inparent teacher 						//0 
			with #dli{GNP course (course# = :course.courseno) 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 course (course# = :course.courseno) 	//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0
  		get next inparent teacher 						//0 
			with #dli{GNP course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 offering						//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0

    // get segment with another PCB and modified SSAs
		get next inparent student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP student			 };	 			//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent student usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  	//0
					     student   };						//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next inparent student usingPCB psb2.offeringPCB	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP offering							//0	 
					     student   };						//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next inparent student usingPCB psb2.offeringPCB	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  	//0
					     offering   };						//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:	
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next inparent course usingPCB psb2.offeringPCB  //0 
			with #dli{GNP offering (XLOC = :XLOC)	 		//0
						  course  };						//0
  		get next inparent course usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP course 							//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};			//1 The last SSA in the DL/I call must be for Course
  		get next inparent course usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP offering (XLOC = :XLOC) 			//0
						extra	 							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};							//0
  		get next inparent course usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP  extra							//1 The segment extra is not a segment in the hierarchy of psb2.offeringPCB
						course};							//0
  		get next inparent course usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP  offering (XLOC = :XLOC) 			//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 			//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
							course};						//0

  	// get arrays of segments with no modifiers and modified SSAs	
		get next inparent students 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  	//0
					     offering							//0 
					     student    		 };				//0
		get next inparent students 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  	//0
					     student    		 };				//0	
		get next inparent  students 						//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP offering							//0 
					     student    		 };				//0	
		get next inparent students 							//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  	//0
					     student							//0 
					     offering    		 };				//1 The last SSA in the DL/I call must be for STUDENT
		get next inparent teachers 							//0 
			with #dli{GNP course (course# = :course.courseno) 		//0
					     offering							//0 
					     teacher  };						//0
		get next inparent teachers 							//0 
			with #dli{GNP course (course# = :course.courseno) 		//0
				     teacher  };							//0	
		get next inparent teachers 							//0 
			with #dli{GNP teacher  };						//0
		get next inparent teachers 							//0 
			with #dli{GNP offering							//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB. 
						course (course# = :course.courseno) 		//0
					     teacher  };						//0
		get next inparent teachers 							//0 
			with #dli{GNP garbage (course# = :course.courseno) 	//1 The segment garbage is not a segment in the hierarchy of psb2.coursePCB
					     offering							//0 
					     teacher  };						//0
		get next inparent teachers 							//0 
			with #dli{GNP course (course# = :course.courseno) 		//0
						extra								//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     offering							//0 
					     teacher  };						//0
		get next inparent teachers 							//0 
			with #dli{GNP course (course# = :course.courseno) 		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						course								//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     offering							//0 
					     teacher  };						//0
		// The D command code is invalid because it's presence would require that multiple segments be
		// listed as I/O objects.  But, you can't specify multiple targets when one is an array.
		get next inparent teachers 								//0 
			with #dli{GNP course*d  							//2 D is not a valid command code for a GNP call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the course segment
					     offering								//0 
					     teacher 		 };	

    // get arrays of segments with another PCB and modified SSAs
		get next inparent students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  		//0
					     offering								//0 
					     student    		 };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  		//0
					     student    		 };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB	
		get next inparent students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP offering								//0 
					     student    		 };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB	
		get next inparent students usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP course (course# = :course.courseno)  		//0
					     student								//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 
					     offering    		 };					//1 The last SSA in the DL/I call must be for STUDENT
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP offering (XLOC = :XLOC)	 			//0
						  course  };							//0
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP course 								//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};				//1 The last SSA in the DL/I call must be for Course
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP offering (XLOC = :XLOC) 				//0
						extra	 								//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};								//0
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP  extra								//1 The segment extra is not a segment in the hierarchy of psb2.offeringPCB
						course};								//0
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP  offering (XLOC = :XLOC) 				//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 				//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
						course};								//0
  		get next inparent courses usingPCB psb2.offeringPCB 	//0 
			with #dli{GNP offering*d (XLOC = :XLOC)	 			//2 D is not a valid command code for a GNP call when the target of the statement is an array|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment
						  course  };							//0
   
    // get segments using path calls and modified SSAs
		get next inparent course, offering, student 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GNP course*D (course# = :course.courseno)//0 
					     offering						//1 The D command code is required on the SSA for the offering segment 
					     student   };					//0
		get next inparent course, offering, student 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GNP course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for Offering 
					     student   };					//0
		get next inparent course, offering, student 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GNP course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for STUDENT 
					     offering	};					//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment
		get next inparent offering, teacher 		 	//0
			with #dli{GNP offering*D					//0
					     teacher  };					//0
		get next inparent course, offering, teacher 	//0
			with #dli{GNP course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for Offering
					     teacher };						//0
		get next inparent course, offering, teacher 	//0
			with #dli{GNP course*D (course# = :course.courseno)//1 There must be an SSA for each target of the statement. None found for TEACHER  
					     offering				 };		//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next inparent course, offering, teacher 	//0
			with #dli{GNP course*D (course# = :course.courseno)//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 		//0
					     offering	 };					//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next inparent course, offering, teacher 	//0
			with #dli{GNP garbage*D (course# = :course.courseno)//3 There must be an SSA for each target of the statement|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering						//1 The D command code is required on the SSA for the offering segment
					     teacher  };					//0	
		get next inparent course, offering, teacher 	//0
			with #dli{GNP course*D (course# = :course.courseno)//0
					     offering						//1 The D command code is required on the SSA for the offering segment
					     extra							//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher  };					//0
		get next inparent course, offering, teacher 	//0
			with #dli{GNP course (course# = :course.courseno)  //2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB|The D command code is required on the SSA for the course segment
						 course (title > "abc")			//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering						//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0
	 			
    // get segments using path calls, another PCB, and modified SSAs
   		get next inparent offering, student usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP  offering*D (XLOC = :XLOC)					//0
						  student };									//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent offering, student usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GNP  offering*D (XLOC = :XLOC)					//1 There must be an SSA for each target of the statement
						  course };										//1 The last SSA in the DL/I call must be for STUDENT						  
		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GNP  teacher (emp# = :teacher.empno)};					//2 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB|There must be an SSA for each target of the statement. None found for Offering
		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GNP  offering*D (XLOC = :XLOC)	};				//2 There must be an SSA for each target of the statement. None found for TEACHER|The last SSA in the DL/I call must be for TEACHER
		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GNP  teacher (emp# = :teacher.empno)						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};					//1 The last SSA in the DL/I call must be for TEACHER
		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GNP  garbage*D (XLOC = :XLOC)						//3 There must be an SSA for each target of the statement. None found for Offering|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GNP  offering*D (XLOC = :XLOC)					//0
						  extra											//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get next inparent offering, teacher usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GNP  offering*D (XLOC = :XLOC)					//0
						  teacher (emp# = :teacher.empno)						//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};						//2 Multiple SSAs for DL/I Segment teacher found. Only one SSA per DL/I segment is allowed in a DL/I call|    					     
	end
	
 	function getNextInParentForUpdateStmt() 
	// It's dangerous but valid to specify every level of segment in the hierarchy.
	// Since we don't know where parentage is set, there is nothing additional we can check.
		get next inparent student forupdate 			//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHNP student			 };	 		//0
		get next inparent student forupdate 			//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHNP course (course# = :course.courseno) //0
					     student   };					//0 		
		get next inparent student forupdate 			//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHNP offering						//0	 
					     student   };					//0 		
		get next inparent student forupdate 			//1 No PCB in psb2 contains the STUDENT segment
			with #dli{GHNP course (course# = :course.courseno) //0
					     offering   };					//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course (course# = :course.courseno) //0
						 offering						//0
					     teacher };						//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course 					 	//0
						 offering						//0
					     teacher };						//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP offering						//0
					     teacher };						//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP teacher };					//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course (course# = :course.courseno) //0
						 teacher };						//0	
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course }; 					//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher forupdate 			//0 
			with #dli{GHNP offering						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course (course# = :course.courseno) 	//0
					     teacher };						//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course  					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher						//0
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP teacher						//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
					     offering };					//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher forupdate 			//0 
			with #dli{GHNP teacher 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 course };						//1 The last SSA in the DL/I call must be for TEACHER
 		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course 					 	//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
						 offering						//0
					     teacher };						//0
  		get next inparent teacher forupdate 			//0
			with #dli{GHNP offering						//0
						 extra	 						//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher };						//0
 		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course (course# = :course.courseno) //1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 course (course# = :course.courseno) 	//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0
  		get next inparent teacher forupdate 			//0 
			with #dli{GHNP course 					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 offering						//0
						 offering						//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
					     teacher };						//0

    // get segment with another PCB and modified SSAs
		get next inparent student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP student			 };	 						//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP course (course# = :course.courseno)  				//0
					     student   };									//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next inparent student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP offering										//0	 
					     student   };									//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB 		
		get next inparent student forupdate usingPCB psb2.offeringPCB 	//1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP course (course# = :course.courseno)				  	//0
					     offering   };									//1 The last SSA in the DL/I call must be for STUDENT			
		//I'm picturing the logic this way:
		//  1 find the PCB
		//	2 ensure proper order of SSA to PCB hierarchy (note that the logic for this is different than the get by key 
		// 		logic for this same issue.  In this case, segments can be skipped.
		//  3 look for any extraneous SSAs and duplicate segments
		//  4 ensure "last SSA must be for target segment" (Item 2 by itself is not sufficient because it could be missing)
  		get next inparent course forupdate usingPCB psb2.offeringPCB 	//0 
			with #dli{GHNP offering (XLOC = :XLOC)					 	//0
						  course  };									//0
  		get next inparent course forupdate usingPCB psb2.offeringPCB 	//0 
			with #dli{GHNP course 										//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC)};						//1 The last SSA in the DL/I call must be for Course
  		get next inparent course forupdate usingPCB psb2.offeringPCB 	//0 
			with #dli{GHNP offering (XLOC = :XLOC) 						//0
						extra					 						//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						course};										//0
  		get next inparent course forupdate usingPCB psb2.offeringPCB 	//0 
			with #dli{GHNP  extra										//1 The segment extra is not a segment in the hierarchy of psb2.offeringPCB
						course};										//0
  		get next inparent course forupdate usingPCB psb2.offeringPCB	//0 
			with #dli{GHNP  offering (XLOC = :XLOC)					 	//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.
						offering (XLOC = :XLOC) 						//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
						course};										//0

    // get segments using path calls and modified SSAs
		get next inparent course, offering, student forupdate 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT
			with #dli{GHNP course*D (course# = :course.courseno)		//0 
					     offering								//1 The D command code is required on the SSA for the offering segment 
					     student   };							//0
		get next inparent course, offering, student forupdate 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHNP course*D (course# = :course.courseno)		//1 There must be an SSA for each target of the statement. None found for Offering 
					     student   };							//0
		get next inparent course, offering, student forupdate 	//1 No PCB in psb2 contains the segment hierarchy: COURSE, Offering, STUDENT 
			with #dli{GHNP course*D (course# = :course.courseno)		//1 There must be an SSA for each target of the statement. None found for STUDENT
					     offering	};							//2 The last SSA in the DL/I call must be for STUDENT|The D command code is required on the SSA for the offering segment
		get next inparent offering, teacher forupdate 	 		//0
			with #dli{GHNP offering*D							//0
					     teacher  };							//0
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP course*D (course# = :course.courseno)		//1 There must be an SSA for each target of the statement. None found for Offering
					     teacher };								//0
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP course*D (course# = :course.courseno)		//1 There must be an SSA for each target of the statement. None found for TEACHER  
					     offering				 };				//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP course*D (course# = :course.courseno)		//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						 teacher (emp# = :teacher.empno) 				//0
					     offering	 };							//2 The last SSA in the DL/I call must be for TEACHER|The D command code is required on the SSA for the offering segment
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP garbage*D (course# = :course.courseno)		//3 There must be an SSA for each target of the statement. None found for COURSE|The segment garbage is not a segment in the hierarchy of psb2.coursePCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
					     offering								//1 The D command code is required on the SSA for the offering segment
					     teacher  };							//0	
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP course*D (course# = :course.courseno)		//0
					     offering								//1 The D command code is required on the SSA for the offering segment
					     extra									//1 extra is not a segment in the hierarchy of psb2.coursePCB.
					     teacher  };							//0
		get next inparent course, offering, teacher forupdate 	//0
			with #dli{GHNP course (course# = :course.courseno)  		//2 The D command code is required on the SSA for the course segment|The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
						 course (title > "abc")					//1 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.
						 offering								//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };				//0
	 			
    // get segments using path calls, another PCB, and modified SSAs
   		get next inparent offering, student forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP  offering*D (XLOC = :XLOC)							//0
						  student };											//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent offering, student forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the STUDENT segment
			with #dli{GHNP  offering*D (XLOC = :XLOC)							//1 There must be an SSA for each target of the statement. None found for STUDENT
						  course };												//1 The last SSA in the DL/I call must be for STUDENT						  
		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHNP  teacher (emp# = :teacher.empno)};							//2 The segment teacher is not a segment in the hierarchy of psb2|There must be an SSA for each target of the statement. None found for Offering
		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHNP  offering*D (XLOC = :XLOC)	};						//2 There must be an SSA for each target of the statement. None found for TEACHER|The last SSA in the DL/I call must be for TEACHER
		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHNP  teacher (emp# = :teacher.empno)								//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  offering*D (XLOC = :XLOC)	};							//1 The last SSA in the DL/I call must be for TEACHER
		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHNP  garbage*D (XLOC = :XLOC)							//3 There must be an SSA for each target of the statement. None found for Offering|The segment garbage is not a segment in the hierarchy of psb2.offeringPCB|Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement
						  teacher (emp# = :teacher.empno)};								//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB //1 The pcb psb2.offeringPCB does not contain the TEACHER segment
			with #dli{GHNP  offering*D (XLOC = :XLOC)							//0
						  extra													//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
					      teacher (emp# = :teacher.empno)};								//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
 		get next inparent offering, teacher forupdate usingPCB psb2.offeringPCB	//1 The pcb psb2.offeringPCB does not contain the TEACHER segment 
			with #dli{GHNP  offering*D (XLOC = :XLOC)							//0 
						  teacher (emp# = :teacher.empno)								//1 The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
						  teacher (emp# = :teacher.empno)};								//2 Multiple SSAs for DL/I Segment teacher found|The segment teacher is not a segment in the hierarchy of psb2.offeringPCB
	end 	
	
  function replaceStmt()
  	// It's legal to leave out segments!  But they still have to be in the correct order
  	  replace student  						//1 No PCB in psb2 contains the STUDENT segment	 
  	  		with #dli{REPL  student } ;		//0
  	  replace student  						//1 No PCB in psb2 contains the STUDENT segment	 
  	  		with #dli{REPL  course			//0
						offering			//0
						student } ;			//0
  	  replace student  						//1 No PCB in psb2 contains the STUDENT segment	 
  	  		with #dli{REPL  offering } ;	//1 The last SSA in the DL/I call must be for STUDENT
	  replace student  						//1 No PCB in psb2 contains the STUDENT segment	 
  	  		with #dli{REPL  course (course# = :course.courseno)//1 SSAs for the REPL function code cannot contain a qualification statement.
						offering*n			//0
						student } ;			//0
	  replace teacher						//0
			with #dli{REPL  course			//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB.
						teacher				//0
						offering };			//1 The last SSA in the DL/I call must be for TEACHER
	  replace teacher  						//0
  	  		with #dli{REPL  garbage			//1 The segment garbage is not a segment in the hierarchy of psb2.coursePCB
						offering 			//0
						teacher } ;			//0	
	  replace teacher						//0
			with #dli{REPL  course			//0 
						offering			//0
						extra	 			//1 extra is not a segment in the hierarchy of psb2.coursePCB.
						teacher };			//0
	  replace teacher						//0
			with #dli{REPL  course			//1 The SSA hierarchy must follow the segment hierarchy in PCB psb2.coursePCB
						offering			//0
						offering	 		//1 Multiple SSAs for DL/I Segment offering found. Only one SSA per DL/I segment is allowed in a DL/I call.
						teacher };			//0

// replace segment with another PCB and modified SSAs 
	  replace student usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the student segment 
			with #dli{REPL  offering (XLOC = :XLOC)	 	//1 SSAs for the REPL function code cannot contain a qualification statement
						  student };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB
	  replace student usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the student segment 
			with #dli{REPL  offering (XLOC = :XLOC) };	//2 The last SSA in the DL/I call must be for STUDENT|SSAs for the REPL function code cannot contain a qualification statement
	  replace student usingPCB psb2.offeringPCB  		//1 psb2.offeringPCB does not contain the student segment 
			with #dli{REPL  offering (XLOC = :XLOC)	 	//1 SSAs for the REPL function code cannot contain a qualification statement
						  student };					//1 The segment student is not a segment in the hierarchy of psb2.offeringPCB

	  replace course usingPCB psb2.offeringPCB  		//0
			with #dli{REPL  course (course# = :course.courseno)//2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB.|SSAs for the REPL function code cannot contain a qualification statement
						  offering (XLOC = :XLOC)	 }; //2 The last SSA in the DL/I call must be for COURSE|SSAs for the REPL function code cannot contain a qualification statement						  
	  replace course usingPCB psb2.offeringPCB  		//0
			with #dli{REPL  offering (XLOC = :XLOC)		//1 SSAs for the REPL function code cannot contain a qualification statement
						  garbage (course# = :course.courseno)};//3 The segment garbage is not a segment in the hierarchy of psb2.offeringPCB| The last SSA in the DL/I call must be for COURSE|SSAs for the REPL function code cannot contain a qualification statement
	  replace course usingPCB psb2.offeringPCB  		//0
			with #dli{REPL  offering (XLOC = :XLOC)	 	//1 SSAs for the REPL function code cannot contain a qualification statement
						  extra							//1 extra is not a segment in the hierarchy of psb2.offeringPCB.
						  course (course# = :course.courseno)};//1 SSAs for the REPL function code cannot contain a qualification statement
	  replace course usingPCB psb2.offeringPCB  		//0
			with #dli{REPL  offering (XLOC = :XLOC)	 	//2 The SSA hierarchy must follow the segment hierarchy in PCB psb2.offeringPCB|SSAs for the REPL function code cannot contain a qualification statement
						  course (title >"defg")		//1 SSAs for the REPL function code cannot contain a qualification statement
						  course (course# = :course.courseno)};//2 Multiple SSAs for DL/I Segment course found. Only one SSA per DL/I segment is allowed in a DL/I call.|SSAs for the REPL function code cannot contain a qualification statement
	 
  end


end

// I think these are covered above, but just in case.....
//1) Any SSA containing a path call must have a corresponding target on the I/O statement
//2) For the get stmts with multiple targets, 
//   - the SSA for each target (except the last target), must have a path call
//   - the targets must follow the hierarchy of the PCB
//3) For add stmt with multiple targets
//   - the SSA for the first target must have a path call (this is already done!)
//   - the targets MUST be consecutive (all segments specified between the first and last target)
// 
program DLIProgramsShortNamesModifiedSSAs2_invalid type textUIProgram 
  { includeReferencedFunctions = yes, allowUnqualifiedItemReferences = yes,
  @DLI { psb = psb2, 					 
         handleHardDLIErrors = yes }	 
  }
  course course;						   
  prereq prereq;						 
  offering offering;					 
  teacher teacher;						 
  student student;						 
  courses course[20];					   
  prereqs prereq[5];					 
  offers offering[3];					 
  teachers teacher[5];					 
  students student[25];					   
  xloc char(4);							 

  // PSB Declaration
  psb2 EducationPSB3 ;					 

  	function main()
		addStmt();
		getStmt();
		getForUpdateStmt();
		getNextStmt();
		getNextForUpdateStmt();
		getNextInParentStmt();
		getNextInParentForUpdateStmt(); 
  	end
  	function addStmt()	
  	   add offering, teacher 							//0
   	  		with #dli{ISRT course*d						//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the course segment.
   	  					   offering*D		  			//0
  	  					   teacher};					//0	
 	  add course, offering, teacher 					//0
   	  		with #dli{ISRT course						//1 The D command code is required on the SSA for the course segment.
   	  					   offering*D		  			//0
  	  					   teacher};					//0
  	  add course, teacher 								//1 On an ADD statement with multiple targets, the I/O targets must follow the segment hierarchy in PCB psb2.coursePCB. A target must be specified for each segment between the first and last target
   	  		with #dli{ISRT course*d  					//0
  	  					   teacher};					//0  
 	end  
 	function getStmt() 
		get   offering, teacher 								//0
			with #dli{GU course*D (course# = :course.courseno) 	//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the course segment.
					     offering*d								//0
					     teacher (emp# = :teacher.empno) };		//0
		get offering, course, teacher 							//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GU course*D (course# = :course.courseno) 	//0
					     offering								//1 The D command code is required on the SSA for the offering segment
					     teacher (emp# = :teacher.empno) };		//0
	end  
	
 	function getForUpdateStmt() 
		get course,  TEACHER forupdate 							//0
			with #dli{GHU course*D (course# = :course.courseno)	//0
					     offering*d								//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment.
					     teacher };								//0	
		get offering, course, TEACHER forupdate 				//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GHU course*D (course# = :course.courseno)	//0
					     offering 								//1 The D command code is required on the SSA for the offering segment
					     teacher };								//0	
	end 
 	  
 	function getNextStmt() 
  		get next  teacher 		 								//0
			with #dli{GN offering*D								//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment.
					     teacher  };							//0
  		get next  offering, course, teacher 					//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GN course*d (course# = :course.courseno)	//0
						offering 								//1 The D command code is required on the SSA for the offering segment
					     teacher  };							//0
	end   

 	function getNextForUpdateStmt() 
		get next teacher forupdate						 		//0
			with #dli{GHN  offering*D							//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment.
					     teacher  };							//0
		get next offering, course,  teacher forupdate	 		//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GHN course*d (course# = :course.courseno)	//0  
						offering 								//1 The D command code is required on the SSA for the offering segment
					     teacher  };							//0
	end 

 	function getNextInParentStmt() 
		get next inparent  teacher 							 	//0
			with #dli{GNP offering*D							//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment.
						  teacher };							//0
		get next inparent  offering, course, teacher 		 	//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GNP course  (course# = :course.courseno)	//1 The D command code is required on the SSA for the course segment
						  offering*D							//0
						  teacher };							//0					  
	end
	
 	function getNextInParentForUpdateStmt() 
		get next inparent  teacher forupdate 			 		//0
			with #dli{GHNP offering*D							//1 Every SSA that specifies the D command code must have a corresponding DLISegmentRecord target on the I/O statement. No target was found for the offering segment.
					     teacher  };							//0
		get next inparent  offering, course, teacher forupdate 	//1 No PCB in psb2 contains the segment hierarchy: Offering, COURSE, TEACHER
			with #dli{GHNP course  (course# = :course.courseno)	//1 The D command code is required on the SSA for the course segment
						  offering*D							//0
						  teacher };							//0						     
	end 	

end
